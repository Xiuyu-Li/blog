{"componentChunkName":"component---src-templates-blog-post-js","path":"/simple-java-fact/","result":{"data":{"site":{"siteMetadata":{"title":"Xiu's Blog"}},"markdownRemark":{"id":"938af32f-f9ea-56db-8123-14b73976e7d5","excerpt":"观察以下代码： 很显然  的结果应该是 ，由于是使用  创建的 ，a 和 b 是的地址是指向堆（heap）中对常量池（constant pool）的对象 “Hello” 的不同的拷贝对象地址。 则应该是 ，因为它们是直接指向常量池中的同一个地址的（JVM 对于 String…","html":"<p>观察以下代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HelloWorld</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">String</span> a <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">String</span> b <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">String</span> a1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">String</span> b1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">String</span> c <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> <span class=\"token string\">\"World\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">String</span> d <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> <span class=\"token string\">\"World\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">String</span> e <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"World\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">String</span> f <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"World\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">==</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a1 <span class=\"token operator\">==</span> b1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">==</span> f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>很显然 <code class=\"language-text\">a1 == b1</code> 的结果应该是 <code class=\"language-text\">false</code>，由于是使用 <code class=\"language-text\">new</code> 创建的 <code class=\"language-text\">String</code>，a 和 b 是的地址是指向堆（<em>heap</em>）中对常量池（<em>constant pool</em>）的对象 “Hello” 的不同的拷贝对象地址。<code class=\"language-text\">a == b</code> 则应该是 <code class=\"language-text\">true</code>，因为它们是直接指向常量池中的同一个地址的（JVM 对于 String 的存储采用了常量池的机制，在这里不过多介绍）。</p>\n<p>有趣的地方在于 <code class=\"language-text\">c == d</code> 和 <code class=\"language-text\">e == f</code>，他们的结果应该是什么，是否相同呢？其实 <code class=\"language-text\">c == d</code> 是 <code class=\"language-text\">false</code> 相对来说也算显然，毕竟 a 并不是一个常数，因此编译器无法判断 <code class=\"language-text\">a + &quot;world&quot;</code> 是否在常量池里面，只能在堆中直接创建 c 和 d 应该指向的地址，所以是不同的。但 <code class=\"language-text\">e == f</code> 结果却是 <code class=\"language-text\">true</code>，说明 “HelloWorld” 是在常量池里面的，并且 e 和 f 都指向其地址。但我们在之前并没有直接创建值为 “HelloWorld” 的 <code class=\"language-text\">String</code>，为什么 “HelloWorld” 会在常量池里面？这里就必须引入 <em>constant folding</em> 的概念，出于自己对编译原理知之甚少，直接搬运 <a href=\"https://en.wikipedia.org/wiki/Constant_folding?oldformat=true\"><em>Wikeapedia</em></a> 的介绍：</p>\n<blockquote>\n<p><strong>Constant folding</strong> is the process of recognizing and evaluating constant expressions at compile time rather than computing them at runtime. Terms in constant expressions are typically simple literals, such as the integer literal 2, but they may also be variables whose values are known at compile time. </p>\n</blockquote>\n<p>大部分编译器并不会产生运算的指令并等到 run time 在计算出结果，而是采用一种叫做 constant folding 的优化方法，在 compile time 的时候就分辨出语句结构，计算出结果。JVM 编译器也采用了 constant folding，在 compile time 的时候就把 <code class=\"language-text\">&quot;Hello&quot; + &quot;World&quot;</code> 处理成了 “HelloWorld”，所以 e 和 f 都指向了常量池中的 “HelloWorld” 而并没有在堆中新建对象。JVM 编译器实际上还采用了另外一个优化方法 <em>constant propagation</em>：</p>\n<blockquote>\n<p><strong>Constant propagation</strong> is the process of substituting the values of known constants in expressions at compile time. Such constants include those defined above, as well as intrinsic functions applied to constant values. </p>\n</blockquote>\n<p>理论上来说，因为 constant propagation 会处理变量，<code class=\"language-text\">a + &quot;world&quot;</code> 的结果也可以在 compile time 的时候计算出来。但对编译器而言，优化的程度和效率通常是不能兼顾的，而 JVM 编译器并没有在 String 相加的时候进行 constant propagation 的优化。</p>\n<p>出于好奇，我又在 Python 上进行了一次实验：</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">a <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span>\nb <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span>\nc <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> <span class=\"token string\">\"World\"</span>\nd <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> <span class=\"token string\">\"World\"</span>\ne <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"World\"</span>\nf <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"World\"</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">==</span> b<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> d<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">==</span> f<span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">a == b</code> 显然正确，不多提。<code class=\"language-text\">e == f</code> 也是正确的，看来 Python 编译器也使用了 <code class=\"language-text\">constant folding</code> 进行优化。然而奇怪的是，<code class=\"language-text\">c == d</code> 居然也是正确的？难道 Python 对于 String 的储存机制有什么特别之处？但我在运行 <code class=\"language-text\">id(c)</code> 和 <code class=\"language-text\">id(d)</code> 之后发现 c 和 d 的地址并不相同。原来 Python 中对于 String 的 <code class=\"language-text\">==</code>  其实是比较两个 String 的值是否相同，相当于 Java 的 <code class=\"language-text\">.equals()</code>，实在是坑爹。在运行 <code class=\"language-text\">print(c is d)</code> 之后，果然得到了 <code class=\"language-text\">false</code> 的结果。</p>\n<p>这个文章可以说是非常 trivial 了，权当茶余饭后随记一篇。</p>","frontmatter":{"title":"浅谈 Java String 类参数传递","date":"September 02, 2018","description":"大一完全不懂编译原理时写的水文，当时可真是 naive =="}}},"pageContext":{"slug":"/simple-java-fact/","previous":{"fields":{"slug":"/determinant-problem/"},"frontmatter":{"title":"一道有趣的行列式习题"}},"next":{"fields":{"slug":"/java-unsound/"},"frontmatter":{"title":"Java is unsound: 对 wildcard capture 的案例分析"}}}}}