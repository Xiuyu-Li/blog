<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Olórin&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lixiuyu.cc/"/>
  <updated>2019-05-25T04:19:15.098Z</updated>
  <id>http://lixiuyu.cc/</id>
  
  <author>
    <name>Olórin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Baby Rudin Chapter 1-6 总结</title>
    <link href="http://lixiuyu.cc/2019/05/09/rudin/"/>
    <id>http://lixiuyu.cc/2019/05/09/rudin/</id>
    <published>2019-05-09T04:37:23.000Z</published>
    <updated>2019-05-25T04:19:15.098Z</updated>
    
    <content type="html"><![CDATA[<p>在 Spring 2019 学期我在康村上了 MATH 4130: Honors Introduction to Analysis I，虽然最后成绩差强人意，但确实是我在该学期最有意思的一门课 (相对应的是，一些我不感兴趣也没花多少时间的课成绩反而很好…)。这门课采用著名数分课本 Baby Rudin 作为教材，讲述了其 Ch1-Ch6 的内容，以下是我个人对课程脉络的一个梳理。</p><a id="more"></a><p>附录有我的课程笔记和一些在上课过程中发现的有用的资源，感兴趣的读者也可以参阅。</p><h2 id="Chapter-1-The-Real-and-Complex-Number-Systems"><a href="#Chapter-1-The-Real-and-Complex-Number-Systems" class="headerlink" title="Chapter 1 The Real and Complex Number Systems"></a>Chapter 1 The Real and Complex Number Systems</h2><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>本书的第一章主要定义了一般的域和有序域，以及讨论了一系列命题及证明，内容不多。按本人比较 engineering 的粗浅理解，这一章规范化了一套最底层的定义，并提供了一些比较基础的证明 tactics，诸如 Least Upper Bound Property (<strong>非常重要</strong>) 和 Archimedean Property、Schwarz 不等式等为之后引申出 coutability、continuity 等更加高层的定义提供了理论基础与数学工具。</p><p>本章另外一个值得注意的地方就是讨论了从有理数到实数的扩张。附录介绍了 Dedekind Cut，通过有理数集 $\mathbb{Q}$ 找出了一个集合 $\mathbb{R}$，并论证了这个域在与有理数域的同时具有所有实数集的性质，因此完成了实数集的构建。</p><p>复数 MATH 4130 并未涉及，故此文也并不讨论。</p><h3 id="Selected-Definitions-and-Theorems"><a href="#Selected-Definitions-and-Theorems" class="headerlink" title="Selected Definitions and Theorems"></a>Selected Definitions and Theorems</h3><ul><li><strong>1.7 Definition</strong> $E$ is bounded above if there is $y \in S$ s.t $x \leq y$ for all $x \in E$. We say that $y \in S$ is an <strong>upper bound</strong> for $E$ if $x \leq y$ for all $S \in E$. </li><li><strong>1.8 Definition</strong> Suppose S is an ordered set, $E \subset S$, and $E$ is bounded above. Suppose there exists an $\alpha \in S$ and $\alpha$ is the <strong>least upper bound</strong> if for each upper bound $y$ for $E$ we have $\alpha \leq y$ and $\alpha$ is an upper bound for $E$.</li><li><strong>1.10 Definition</strong> A linear ordered set $S$ has the <strong>least upper bound property</strong> if for each $E \subset S$ s.t. $E$ is bounded above and is non empty, then $E$ has a least upper bound.</li><li><strong>1.11 Theorem</strong> $S$ an ordered set with the least upper bound property. Let $B \subset S$, $B \neq \emptyset$ and bounded below. Let $L=$ all lower bounds of $B$. Then $L$ is bounded above, non empty and so $\alpha = \sup L$ exists and $\alpha$ is the greatest lower bound for $B$.</li><li><strong>1.20 Theorem</strong><ul><li><strong>Archimedean Property</strong> If $x, y \in \mathbb{R}$, $x &gt; 0$, then there exists a natural n s.t $nx &gt; y$</li><li><strong>$\mathbb{Q}$ is dense in $\mathbb{R}$</strong>  if $x, y \in \mathbb{R}$, $x &lt; y$, then there exists $p \in \mathbb{Q}$ s.t. $x &lt; p &lt; y$</li></ul></li><li><strong>1.37 Theorem (Schwarz Inequality)</strong> Suppose $x, y, z \in \mathbb{R}^k$, then $|x \cdot y| &lt; |x|\cdot|y|$ </li></ul><h2 id="Chapter-2-Basic-Topology"><a href="#Chapter-2-Basic-Topology" class="headerlink" title="Chapter 2 Basic Topology"></a>Chapter 2 Basic Topology</h2><h3 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h3><p>这是我本人最喜欢的一章，主要介绍了一些基础的拓扑学概念与定理，其实严格意义上来说并不能算是数学分析。这一章从可数与不可数的定义讲起，并从2.8到2.14介绍了一系列利用相关性质的定理，比如有理数集是可数的，都比较直观，证明不难。用来证明实数集不可数的对角论证法 (Diagonal Proof) 是一个比较有趣与有用的证明 technique。</p><p>本章的第二部分介绍了<strong>度量空间 (Metric Spaces)</strong>。这是一个非常重要的概念，之后的一切内容都是在度量空间上定义的。接下来2.18到2.30介绍了在度量空间上的一些列定义，包括领域、limit point、interior point、开集、闭集、闭包等，以及相关定理，证明不算抽象，但也 nontrivial，证明方法值得学习。</p><p>2.30-2.37围绕<strong>紧致性 (Compactness)</strong>这一概念进行讨论。从这里开始本章的内容开始变得抽象了起来，这出于紧致性本就是一个杜撰出来的概念，作用相当于平面几何中的辅助线[^1]. 但这个概念非常重要，他的作用相当于把有限和无限、开和闭联系了起来，通过引入这一概念能够得到一些非常好的性质，例如在度量空间 $X$ 上紧致的子集一定在 $X$ 上是闭集和一个有界的闭集一定紧致等等，在之后章节讨论映射和连续性的时候也可以反映这一点。</p><p>2.38-2.42 将集合与区间对应起来，并把本章之前的内容从 $\mathbb{R}$ 推广到了 $\mathbb{R}^k$ 上。最后关于 Perfect Set 的内容 MATH 4130 没有涉及，故不再赘述。</p><h3 id="Selected-Definitions-and-Theorems-1"><a href="#Selected-Definitions-and-Theorems-1" class="headerlink" title="Selected Definitions and Theorems"></a>Selected Definitions and Theorems</h3><ul><li><strong>2.4 Definition</strong> $J_n = {1,\ldots,n}$, $n \in \mathbb{N}$<ul><li>$A$ finite if $A \sim J_n$ for some $n$</li><li>$A$ infinite if $A$ is not finite</li><li>$A$ countable if $A \sim \mathbb{N}$</li><li>$A$ at most countable if $A$ countable or finite</li><li>$A$ uncountable if $A$ is not at most countable</li></ul></li><li><strong>2.15 Definition</strong> A metric space $(x, d)$ is a set $X$ and a function $d: X\times X \rightarrow \mathbb{R}$ s.t. <ul><li>$d(p, q) &gt; 0$ if $p,q \in X$, $p \neq q$; $d(p, p) = 0$</li><li>$d(p,q) = d(q, p)$</li><li>$d(p, q) &lt; d(p, r) + d(r, q)$, for any $r \in X$</li></ul></li><li><strong>2.18 Definition</strong> Let $X$ be a metric space<ul><li>A <em>neighborhood</em> of a point $p$ is a set $Nr(p)$ consisting of all points $q$ such that $d(p, q) &lt; r$. The number $r$ is called the radius of $Nr(p)$</li><li>A point $p$ is a limit point of the set $E$ if every neighborhood of $p$ contains a point $q \neq p$ such that $q \in E$</li><li>$E$ is <em>closed</em> if every <em>limit</em> point of $E$ is a point of $E$</li><li>A point $p$ is an <em>interior</em> point of $E$ if there is a neighborhood $N$ of $p$ such that $N \subset E$</li><li>$E$ is <em>open</em> if every point of $E$ is an interior point of $E$ </li></ul></li><li><strong>2.32 Definition</strong> A subset $K$ of a metric space $X$ is said to be <strong>compact</strong> if every open cover of $K$ contains a finite subcover.</li></ul><h2 id="Chapter-3-Numerical-Sequences-and-Series"><a href="#Chapter-3-Numerical-Sequences-and-Series" class="headerlink" title="Chapter 3 Numerical Sequences and Series"></a>Chapter 3 Numerical Sequences and Series</h2><h3 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary"></a>Summary</h3><p>这一章主要讲了序列的极限和收敛性，与高数的内容有诸多重合之处，并没有太多新奇的地方。值得注意的是本章把在度量空间中集合的 limit point 与序列收敛建立了联系，每一个该集合的 limit point 都是一个该集合序列的极限。</p><p>柯西序列是本章的一个重点。柯西序列的定义非常有意思，一定要结合相关定理仔细揣摩其背后的动机。通过柯西序列引出了一系列定义和定理，诸如 diameter，complete metric space，收敛序列一定是柯西序列，紧致空间上的柯西序列一定收敛于空间内的某一点等等，都应当仔细阅读。</p><p>其他如 epsilon-delta，序列的单调性等定义都是基础中的基础，一定要熟记与掌握。子序列极限的最小上界和最小下界的定义相对本章其他内容较为抽象，但在涉及子序列的题目中会有用。一些重要的极限例如$\sqrt[n]{n}$应当记忆。</p><p>后续关于判敛和级数 MATH 4130 没有涉及，本文也不讨论。</p><h3 id="Selected-Definitions-and-Theorems-2"><a href="#Selected-Definitions-and-Theorems-2" class="headerlink" title="Selected Definitions and Theorems"></a>Selected Definitions and Theorems</h3><ul><li><strong>3.2 Theorem</strong> Let $(X, d)$ be metric space, $E \subseteq X$, $p \in X$, $p$ is a limit point of $X$ iff there is a sequence $p_n \in E$ s.t. $\lim_{n \to \infty} p_n \rightarrow  p$ and $p_n \neq p$ for all $n$.</li><li><strong>3.8 Definition</strong> A sequence {$p_n$} in a metric space $(X, d) $ is said to be a <strong>Cauchy sequence</strong> if for every $\epsilon &gt; 0$ there is an integer $N$ such that $d(p_n , p_m) &lt; \epsilon$ if $n &gt; N$ and $m &gt; N$.</li><li><strong>3.9 Definition</strong> For $E \subseteq X$, $(X, d)$ a metric space, $Diam(E) = \sup {d(x, y)|x, y \in E}$.</li></ul><h2 id="Chapter-4-Continuity"><a href="#Chapter-4-Continuity" class="headerlink" title="Chapter 4 Continuity"></a>Chapter 4 Continuity</h2><p>本章开始进入连续性的讨论，这一章的内容是重中之重。本章的前半部分围绕着函数的极限进行了一系列的讨论，与序列的极限十分相似，只是把 $p_n$ 换成了 $f(x)$。虽然说不同之处在于函数的定义域不仅限于整数，但核心思想都是 $\delta-\epsilon$ 法则，很容易可以触类旁通。</p><p>4.5之后的内容则是本章的重点——连续性了。其实连续性定义的核心也是 $\delta - \epsilon$ 法则，一系列相关的性质也可以从这一点着手进行证明，比如连续函数的加减乘除和复合都是连续的。从4.5到4.12都是这些基础性质的讨论。4.13开始将连续性和紧致性联系起来，是本章的点睛之笔。其实在之前的定理4.8就已经介绍了从集合的角度如何定义连续性，从而无需涉及极限，使许多集合上诸如紧致性等一些很好的性质得以利用起来。4.13之后的一系列定理则正是这一点的具体示例，例如4.14说明定义域是紧致集的连续函数的值域也是紧致集; 4.18定义了一致连续，介绍了一个更加苛刻的连续性定义；4.19通过紧致性把连续和一致连续建立了联系，定义域是紧致集的连续函数一致连续。这一部分的内容非常精彩，应当反复研读并认真完成对应习题。</p><p>接下来对连通性和间断点的讨论结论都可以通过对之前内容的运用得到，不难理解。本章最后引入正无穷和负无穷到极限系统中，与第一章最后实数域的完备相对应，都是使整个系统更加完备。</p><p>这一章由于涉及的概念比较多，并且可以互相联系，习题相对较难，建议花费更多时间做更多练习，并且要注意总结方法。关于连续性和紧致性的概念和定理都要熟记，尤其要注意一直连续和连续的区别。</p><h3 id="Selected-Definitions-and-Theorems-3"><a href="#Selected-Definitions-and-Theorems-3" class="headerlink" title="Selected Definitions and Theorems"></a>Selected Definitions and Theorems</h3><ul><li><strong>4.8 Theorem</strong> For $f: X \rightarrow Y$, $f$ is continuous iff $f^{-1}(V)$ is open for each $V \subseteq Y$ open.</li><li><strong>4.14 Theorem</strong> For $f: X \rightarrow Y$ continuous, $X$ compact then $f(X)$ is compact. </li><li><strong>4.18 Definition</strong> For $f: X \rightarrow Y$, we say that $f$ is <strong>uniformly continuous</strong> on $X$ if for every $\epsilon &gt; 0$ there exists $\delta &gt; 0$ s.t. $d_Y(f(p), f(q)) &lt; \epsilon$ for all $p$, $q$ in $X$ for which $d_X(p, q) &lt; \delta$.</li><li><strong>4.19 Theorem</strong> For $f: X \rightarrow Y$ continuous, $X$ compact then $f(X)$ is uniformly continuous.  </li></ul><h2 id="Chapter-5-Differentiation"><a href="#Chapter-5-Differentiation" class="headerlink" title="Chapter 5 Differentiation"></a>Chapter 5 Differentiation</h2><h3 id="Summary-3"><a href="#Summary-3" class="headerlink" title="Summary"></a>Summary</h3><p>这一章的内容基本与高数大同小异，介绍了导数的定义，可导性的判断，以及各种微分重要定理(微分中值定理，介值定理，洛必达法则，泰勒公式)。定理的证明不算抽象，但证明方法都比较有代表性，比如洛必达法则证明中的放缩和泰勒公式证明中的归纳法，值得仔细研读。</p><p>最后讨论了从一元函数拓展到了向量值函数，讨论了诸多关于一元函数中的微分定理在向量值函数的情况下未必成立，会有所不同。</p><h3 id="Selected-Definitions-and-Theorems-4"><a href="#Selected-Definitions-and-Theorems-4" class="headerlink" title="Selected Definitions and Theorems"></a>Selected Definitions and Theorems</h3><p>关于导数和微分方面的知识与定理大家在之前的学习中都已经十分熟悉，就不再赘述，只简单列一个向量值函数的微分中值定理：</p><p><strong>5.19 Theorem</strong> Suppose $f: [a, b] \rightarrow \mathbb{R}^k$ continuous, $f$ differentiable on $[a, b]$, then there exists $x \in [a, b]$ s.t. $|f(b) - f(a)| &lt; (b - a) |f’(x)|$ .</p><h2 id="Chapter-6-The-Riemann-Stieltjes-Integral"><a href="#Chapter-6-The-Riemann-Stieltjes-Integral" class="headerlink" title="Chapter 6 The Riemann-Stieltjes Integral"></a>Chapter 6 The Riemann-Stieltjes Integral</h2><h3 id="Summary-4"><a href="#Summary-4" class="headerlink" title="Summary"></a>Summary</h3><p>在上一章讲了微分之后，这一章自然开始讨论积分。6.1到6.7基本都围绕这黎曼积分的定义进行讨论，这个定义比较有意思，大致是把一个区间 $[a,  b]$ 分割成有限个小区间，每个小区间内取该函数的最小上界和最大下界，假设这个区间的两个端点是 $x_{i-1}$ 和 $x_i$，有一个单调递增函数$\alpha: [a,b] \rightarrow \mathbb{R}$，则各个区间函数的最小上界与 $(\alpha(x_i) - \alpha(x_{i - 1}))$ 相乘之和就是上黎曼积分，最大下界则为下黎曼积分。从所有可能分割中取上黎曼积分的最大下界和下黎曼积分的最小上界，这两个值应该都趋近于同一个常数，即 $f$ 在 $[a,b]$ 上积分的值。可以看出黎曼积分的定义中包含着一种夹逼的思想，而在6.6又回归到采用收敛来定义，有对于任意 $\epsilon &gt; 0$，上黎曼积分与下黎曼积分之差必定小于 $\epsilon$。这使得黎曼积分的定义更加量化，便于证明很多其具有的性质。值得注意的是6.4中证明了对于给定分割的细分(refinement)，新的上黎曼积分一定不大于原分割上的上黎曼积分，新的下黎曼积分也不小于原下黎曼积分，这一定理对通过夹逼和收敛定义积分提供了依据，在之后的证明中也时常能够起到很大帮助。</p><p>6.8-6.11主要对可积性的判断进行讨论，6.12-6.19则都是关于黎曼积分性质的各种定理，但从6.8-6.19基本都是运用了黎曼积分的定义，尤其是6.4和6.6，进行证明。把这些证明弄懂对摸清本章习题的解题套路很有帮助，这些定理本身的内容也一定都要熟记。通过这一部分我们也可以发现函数的连续性和单调性(递增)对函数是否可积与黎曼积分的一些性质是否成立都相当重要，并且有些时候被积函数和积分变量可以相互转换。</p><p>有了之前的铺垫，把积分和微分联系起来就十分自然了。6.20-6.22则讨论了这一点，通过黎曼积分定义了我们所熟悉的积分并推导了微积分基本定理和分部积分法，证明不难。6.23-6.25定义并简单讨论了向量值函数上的积分，与微分时的情况不同的是，向量值函数上的积分与一般情况下没有太大不同。最后一部分从数学上定义了曲线并介绍了如何用积分求曲线长度，比较应用</p><h3 id="Selected-Definitions-and-Theorems-5"><a href="#Selected-Definitions-and-Theorems-5" class="headerlink" title="Selected Definitions and Theorems"></a>Selected Definitions and Theorems</h3><ul><li><strong>6.4 Theorem</strong> If $P^<em>$ is a refinement of $P$, then $L(P, f, a) \leq L(P^</em>, f, a)$, $U(P, f, a) \geq U(P^*, f, a)$.</li><li><strong>6.6 Theorem</strong> $f \in R(\alpha) $ on $[a, b]$ iff $\forall \epsilon &gt; 0$ $\exists P$ a partition of $[a, b]$ s.t. $U(P,f,a) - L(P,f,a) &lt; \epsilon$.</li><li><strong>6.8 Theorem</strong> If $f$ is continuous on $[a, b]$ then $f \in R(\alpha)$ on $[a, b]$.</li><li><strong>6.17 Theorem</strong> $\alpha: [a, b] \rightarrow \mathbb{R}$ monotonically increasing and differentiable, $\alpha’ \in R$ on $[a, b]$, $f$ bounded on $[a,b]$. Then $f \in R(\alpha)$ iff $f\alpha’ \in R$ and $\int_{a}^{b}fd\alpha = \int_{a}^{b} f(x)\alpha’(x)dx$.</li><li><strong>6.21 The fundamental theorem of calculus</strong> If $f \in R$ on $[a, b]$ and if there is a differentiable function $F$ on $[a,b]$ s.t. $F’ = f$, then $\int_{a}^{b}f(x)dx = F(b) - F(a)$.</li></ul><h2 id="一点小结"><a href="#一点小结" class="headerlink" title="一点小结"></a>一点小结</h2><p>到这里 MATH 4130 的内容就告一段落了。从这篇文章可以看出1至6章的内容呈一个递进的关系，每一章的定义和定理都为接下来更高层次的内容打下了铺垫，因此在学习的过程中时常会感到每一点的内容都不是割裂的， 没有哪一个定义或定理是多余的，整一个体系十分连贯。这就是数学分析的美妙之处，是离散数学与基础数理统计不具有的（🐶）。</p><p>同时这一点也说明了要学好数学分析必须做到各个定义与定理之间的融会贯通，而想做到这一点十分不易，必须花费大量的时间进行复习，思考，以及习题练习。对于像我一样的资质平平的人而言，如果未能做到这一点，即使在考试中取得了不错的成绩，也很可能并没有真正学懂数分的精髓。这也是我本学期选课的一大失误之处，学分过多导致没有足够的时间花在数分上，我是认为自己并没有学懂的，只掌握了一点皮毛。这也让我认为学校要求过于宽松的 CS + 数学双专业实际上有些毒瘤，让人分心从而哪一科都无法学精，不过这不是本文的重点，暂且按下不表，未来如有机会可能会撰文细细讨论。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[^1]:Rudin:《数学分析原理》第1～7章小结. <a href="http://blog.renren.com/share/242480694/12441429452/1" target="_blank" rel="noopener">http://blog.renren.com/share/242480694/12441429452/1</a>.</p><h2 id="Appendix-A"><a href="#Appendix-A" class="headerlink" title="Appendix A"></a>Appendix A</h2><p>这是我 MATH 4130 的笔记，字迹比较潦草，除我之外的人可能较难看懂，但仍附上以供感兴趣的人参考。</p><p><a href="http://lxywizard.github.io/files/MATH4130_notes.pdf" target="_blank" rel="noopener">note.pdf</a></p><h2 id="Appendix-B"><a href="#Appendix-B" class="headerlink" title="Appendix B"></a>Appendix B</h2><p>以下我在学习过程中发现的一些可能会有帮助的资源：</p><p>CH1:</p><ol><li><a href="https://www.wikiwand.com/zh-hant/%E5%AF%A6%E6%95%B8%E7%9A%84%E6%A7%8B%E9%80%A0" target="_blank" rel="noopener">實數的構造</a> </li></ol><p>Ch2:   </p><ol><li><a href="https://www.zhihu.com/question/31734712/answer/72390708" target="_blank" rel="noopener">如何直观地解释「紧致性」？ - 包遵信的回答 - 知乎</a></li><li><a href="https://math.stackexchange.com/questions/2659151/if-f-subset-mathbbr-and-bounded-then-sup-f-in-barf" target="_blank" rel="noopener">If $F\in \mathbb{R}$ and bounded, then sup $F \in \bar F$</a></li><li><a href="https://math.stackexchange.com/questions/368108/how-to-prove-every-closed-interval-in-r-is-compact" target="_blank" rel="noopener">How to prove every closed interval in $\mathbb{R} $ is compact?</a></li><li><a href="https://math.stackexchange.com/questions/456773/every-bounded-subset-of-rk-lies-in-a-compact-subset-of-rk" target="_blank" rel="noopener">Every bounded subset of $\mathbb{R}^k$ lies in a compact subset of $\mathbb{R}^k $</a></li><li><a href="https://math.stackexchange.com/questions/194201/show-that-in-a-discrete-metric-space-every-subset-is-both-open-and-closed" target="_blank" rel="noopener">Show that in a discrete metric space, every subset is both open and closed.</a></li><li><a href="https://math.stackexchange.com/questions/17649/are-singleton-sets-in-mathbbr-both-closed-and-open" target="_blank" rel="noopener">Are Singleton sets in $\mathbb{R}$ both closed and open?</a></li></ol><p>Ch4:</p><ol><li><a href="https://math.stackexchange.com/questions/668905/if-every-real-valued-continuous-function-is-bounded-on-x-metric-space-then" target="_blank" rel="noopener">If every real-valued continuous function is bounded on $X$ (metric space), then $X$ is compact.</a></li><li><a href="https://math.stackexchange.com/questions/716380/prove-that-if-f-is-bounded-and-nondecreasing-on-a-b-then-lim-fx-as-x" target="_blank" rel="noopener">Prove that if $f$ is bounded and nondecreasing on $[a,b]$ then $\lim f(x)$ as $x$ approaches $b$ from the left exists.</a></li><li><a href="https://math.stackexchange.com/questions/2327671/show-that-exists-a-continuous-function-in-e-that-is-not-bounded" target="_blank" rel="noopener">Show that exists a continuous function in $E$ that is not bounded</a></li><li><a href="https://math.stackexchange.com/questions/263606/prove-that-the-number-of-jump-discontinuities-is-countable-for-any-function" target="_blank" rel="noopener">Prove that the number of jump discontinuities is countable for any function</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Spring 2019 学期我在康村上了 MATH 4130: Honors Introduction to Analysis I，虽然最后成绩差强人意，但确实是我在该学期最有意思的一门课 (相对应的是，一些我不感兴趣也没花多少时间的课成绩反而很好…)。这门课采用著名数分课本 Baby Rudin 作为教材，讲述了其 Ch1-Ch6 的内容，以下是我个人对课程脉络的一个梳理。&lt;/p&gt;
    
    </summary>
    
      <category term="Math" scheme="http://lixiuyu.cc/categories/Math/"/>
    
    
      <category term="Cornell" scheme="http://lixiuyu.cc/tags/Cornell/"/>
    
      <category term="Analysis" scheme="http://lixiuyu.cc/tags/Analysis/"/>
    
  </entry>
  
  <entry>
    <title>康村 CS 2112 Review</title>
    <link href="http://lixiuyu.cc/2018/12/27/CS2112/"/>
    <id>http://lixiuyu.cc/2018/12/27/CS2112/</id>
    <published>2018-12-27T03:31:12.000Z</published>
    <updated>2019-05-25T03:21:26.834Z</updated>
    
    <content type="html"><![CDATA[<p>CS 2112 是我在康村上的第一门 CS 课，叫做 <strong>Object-Oriented Design and Data Structures - Honors</strong>。<a id="more"></a>这门课在康村也是臭名昭著，据说是所有本科 CS 课中作业第二多的（似乎仅次于 Compilers，如果不是欢迎指正），每周大概要花 <strong>15-40 小时</strong>的时间写代码，是我这学期无（chi）法（xu）睡（tuo）觉（fa）的罪魁祸首。我们有一本推荐教材 <em>Data Structures and Problem Solving Using Java, 3rd edition</em>，但从来没有用过 :P 主要是看 <a href="http://www.cs.cornell.edu/courses/cs2112/2018fa/lectures/index.html" target="_blank" rel="noopener">course notes</a>，个人觉得写的还不错。</p><p>这门课虽然名字叫面向对象和数据结构，但其实内容涉及了计算机科学的方方面面，从 Java 基础讲起，再到哈希表、二叉树、排序查找等经典数据结构和算法，之后就开始走偏（?），依次讲了语法分析、设计模式、GUI 设计、并发和同步等内容，最后回归到图论和平衡二叉树。除了平时的 lectures 之外，每周还有由 TA 主持的 recitations 和 labs 帮助我们巩固和拓展知识并动手实践。recitations 和 labs 的质量时好时坏，坏的时候几乎是对 lectures 的重复，令人昏昏欲睡；好的时候内容还是比较有趣，比如 recitations 有讲过有限状态机、3SAT、最小生成树，labs 有让我们练习过正则表达式。</p><p>注重广度固然是个优点，但必然也会导致课堂深度的缺失。然而，2112 的精髓——作业——却“弥补”了这一点。举个例子，九月份的某次作业要求在禁止使用 java.util 的情况下实现诸如哈希表、prefix tree 等数据结构，并且其中有要自己实现队列来实现十一月份才讲的 BFS。后来还有几乎零基础手撸的某个 course 自创语言的 parser，GUI 和 client-server。最后四次作业是一个大 project，总共写了约10000行代码。<strong>可以说是作业才让这门课够得上 “honor” 的名头</strong>。</p><p>总得来说比起很多其他学校的 CS 入门课注重打好坚实的基础，2112 则是浅尝辄止地在课堂上讲一大堆东西给你，并在作业把只会理论的你往“水”里一丢，让你自己学会游泳。好处是除了数据结构之外还涉猎了很多其他 CS 领域的相关知识，同时获得了海量的实践机会。坏处是很多东西都得靠自学囫囵吞枣，为了完成作业“知其然而不知其所以然”，学得并不扎实与愉快。这门课也远远达不到 staff 所吹嘘的可以到工业界当 Java 程序员的地步，不要说诸如 ConcurrentHashMap 等较细的知识点没讲，类加载机制、垃圾回收、内存分配等每个 Java 程序员都必须要掌握的 JVM 相关知识更是一字未提。同时，这门课作业压力极大，性价比很低。这样的“软件工程”课值不值得上就见仁见智了，个人觉得如果兴趣更多偏向于理论方面其实可以选择不上，把时间省下来去上更多更深的数学课（当然大神是可以兼顾的）。</p><p>最后吹一波教授 <a href="http://www.cs.cornell.edu/~kozen/" target="_blank" rel="noopener">Dexter Kozen</a>，虽然本人对这门课有诸多怨言，但对 Prof Kozen 却是由衷地十分敬佩。从他第一堂课所说的 “Don’t be afraid if you think you are not so smart as others. Everyone feels the same. I feel I am not smart all the time through my career. That’s why I work hard. That’s why we should work hard”，到时刻挂在嘴边的 “grade is not the point”，以及最后的寄语 “I hope you to use the CS you learned here to do something good”，无不体现了其之为人师表，给我的影响颇深。两三点秒回的 Piazza 与每周两次的 office hour 更是践行了“传道受业解惑”的典范。因此，为了 Prof Kozen 而选择上 CS 2112 也未尝不可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CS 2112 是我在康村上的第一门 CS 课，叫做 &lt;strong&gt;Object-Oriented Design and Data Structures - Honors&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://lixiuyu.cc/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Cornell" scheme="http://lixiuyu.cc/tags/Cornell/"/>
    
      <category term="Course Review" scheme="http://lixiuyu.cc/tags/Course-Review/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra&#39;s algorithm 和最小生成树算法证明</title>
    <link href="http://lixiuyu.cc/2018/12/22/dijkstra-mst-proof/"/>
    <id>http://lixiuyu.cc/2018/12/22/dijkstra-mst-proof/</id>
    <published>2018-12-21T16:57:58.000Z</published>
    <updated>2018-12-24T13:03:13.829Z</updated>
    
    <content type="html"><![CDATA[<p>Dijkstra’s algorithm 和寻找 minimum spanning tree (MST) 的相关算法都是图论中十分常用而又简洁易懂的算法，但其具体为什么有效仍需要在数学上进行证明。本文即介绍了对这两个大一数据结构课必讲算法的证明，出于我没有接受过正规的算法分析训练，如有纰漏或不严谨之处还望斧正。<a id="more"></a></p><h2 id="Dijkstra’s-algorithm"><a href="#Dijkstra’s-algorithm" class="headerlink" title="Dijkstra’s algorithm"></a>Dijkstra’s algorithm</h2><p>Dijkstra’s algorithm 是一个可以解决 <strong>single-source shortest path</strong> 问题的经典算法，本质上是对广度优先搜索（BFS）的一个推广，只是把 BFS 维护的 <strong>stack</strong> 换成了 <strong>priority queue</strong> 。鉴于这个算法知名度太高，大家对其都已十分熟悉，就不多说废话，直接上基于数学归纳法的证明。</p><p>我们规定 $G$ 为算法所应用的图，$s$ 是源点，$l(u, v)$ 是从点 $u$ 到 $v$ 的边的长度，$V$ 是图中所有的点的集合，那么 Dijkstra’s algorithm 的过程如下所示：</p><img src="/2018/12/22/dijkstra-mst-proof/dijkstra.png" width="820" height="400" alt="Pittsburgh" align="center"><center><font color="#A9A9A9" size="2.5">Dijkstra's algorithm</font></center><p>将算法找到的距离记为 $d(v)$ ，从 $s$ 到 $v$ 的实际最短距离记为 $\delta(v)$ ，我们需要证明对任意 $v \in V$ ，在当前轮递推结束时都有 $d(v) = \delta(v)$ 。这等同于证明 $\forall x \in R$ ， $d(x) = \delta(x)$ 。</p><h3 id="Proof-By-Induction"><a href="#Proof-By-Induction" class="headerlink" title="Proof By Induction"></a>Proof By Induction</h3><p><em>Base case ($|R| = 1$)</em>:  因为 $R$ 的大小会不断增大，只有当 $R = {s}$ 时 $|R| = 1$ ，此时 $d(x) = 0 = \delta(x)$ ，正确。</p><p><em>Induction step</em>: 令 $u$ 为最后一个加进 $R$ 的顶点，记 $R^{‘} = R \cup {u}$ ，则 $\forall x \in R^{‘}$ ， $d(x) = \delta(x)$ 。</p><p>根据 <em>induction step</em> 中的条件，$\forall x \in R^{‘}$ 且 $x \neq u $ ，$d(x) = \delta(x)$ 。因此，我们只需要证明 $d(u) = \delta(u)$ 。Suppose for the sake of contradiction ，存在一从 $s$ 到 $u$ 的最短路径 $Q$ ，使得</p><center>$l(Q) < d(u)$</center> <p>我们可以知道 $Q$ 一定不在 $R^{‘}$ 内结束，同时部分组成 $Q$ 的顶点在 $R^{‘}$ 中。令 $xy$ 为第一个在 $Q$ 中离开 $R^{‘}$ 的路径，$Q_x$ 为在顶点 $x$ 结束的 $Q$ 的子路径，则有</p><center>$l(Q_x) + l(xy) \leq l(Q)$</center><p>同时，因为 $y$ 与 $x$ 相邻，而结束时最后一个更新的顶点是 $u$ ，故 $y$ 一定被算法更新过。根据 Dijkstra’s algorithm ，$d(y) \leq d(x) + l(xy)$ ，所以</p><center>$d(y) \leq l(Q)$</center><p>因为 $x \in R^{‘}$ ，最后一个被加进 $R^{‘}$ 的顶点是 $u$ ，$y$ 则并没有被加进 $R^{‘}$ ，我们可以得到</p><center>$d(u) \leq d(y)$</center><p>而又由于 $l(Q) &lt; d(u)$ ，我们发现 $l(Q) &lt; d(u) \leq d(y) \leq l(Q)$ ，矛盾。所以 $d(u) = \delta(u)$ ，<em>induction step</em> 成立，证毕。</p><h3 id="Another-Proof"><a href="#Another-Proof" class="headerlink" title="Another Proof"></a>Another Proof</h3><p>在我村 CS 2112 的 course note 里还有一个通过 loop invariant 的<a href="http://www.cs.cornell.edu/courses/cs2112/2018fa/lectures/lecture.html?id=ssp" target="_blank" rel="noopener">证明</a>，各位有兴趣的话可以点击链接查看，在此就不展开了。</p><h2 id="Minimum-Spanning-Tree"><a href="#Minimum-Spanning-Tree" class="headerlink" title="Minimum Spanning Tree"></a>Minimum Spanning Tree</h2><p>最小生成树指的是一副联通加权无向图中权值最小的一棵生成树，而寻找最小生成树（MST）也是图论中非常经典的问题。</p><img src="/2018/12/22/dijkstra-mst-proof/mst_example.png" width="430" height="270" alt="Pittsburgh" align="center"><center><font color="#A9A9A9" size="2.5">A minimum spanning tree of a graph</font></center><p>其中最有名的两个寻找 MST 的算法就是 Kruskal’s algorithm 和 Prim’s algorithm，思想分别为：</p><ul><li><strong>Kruskal’s algorithm:</strong> 找到一条权值最小的边，如果其与之前选择过的边形成了一个圈（cycle），丢弃这条边，否则留下。</li><li><strong>Prim’s algorithm:</strong> 从任意顶点出发，选择与该顶点所在的连通分支（connected component）相连的不会形成圈的权值最小的边。</li></ul><p>事实上，包括以上两个经典算法，寻找 MST 的算法都可以被泛化为一个应用 <strong>Red rule</strong> 和 <strong>Blue rule</strong> 的 <strong>贪心算法</strong>：</p><ul><li><strong>Red rule:</strong> 记 $C$ 为一个没有红色边的圈，选择一个在 $C$ 中权值最大且未染色的边，将其染成红色。</li><li><strong>Blue rule:</strong> 记 $D$ 为一个没有蓝色边的割（cut），选择一个在 $D$ 中权值最小且未染色的边，将其染成蓝色。</li><li><strong>Greedy algorithm:</strong> 应用 red 和 blue rules 直到所有边都被染色，所有蓝色的边则组成了一个 MST</li></ul><p>首先，这个算法显然是会终止的，因为任何一个未被染色的边都会和已有的被染过色的集合形成圈或者连通分支，所以其必定落入 red rule 和 blue rule 其中一个的范围中。该算法的正确性（即算法终止时所有蓝色边形成的确实是所在图的最小生成树）同样可以通过数学归纳法来证明。</p><h3 id="Proof-by-Induction"><a href="#Proof-by-Induction" class="headerlink" title="Proof by Induction"></a>Proof by Induction</h3><p><em>Color invariant:</em> 存在一个 MST $T^{*}$ ，使得 $T^*$ 包含所有的蓝色边且不包含任何红色边。</p><p><em>Base case</em>: 当没有任何一条边被染色时，显然 $T^*$ 满足条件，因为不存在任何蓝色边和红色边。</p><p><em>Induction step 1</em>: 假设在应用 blue rule 之前，<em>color invariant</em> 是正确的。</p><p>此时令 $D$ 为被选定的割，$f$ 为被染成蓝色的边，则有以下两种情况：</p><ul><li>$f \in T^*$ ，$T^*$ 满足 invariant。</li><li>$f \notin T^*$ ，记 $f$ 与 $T^*$ 形成的圈为 $C$ （因为 $T^*$ 为图 $G$ 的一棵生成树，$f$ 与 $T^*$ 同在 $G$ 内，$T^* \cup f$ 必形成圈），$e$ 为 $C \cap D$ 除 $f$ 外的另一条边，则 $e \in T^*$。因此，我们可以得到以下两条结论：<ul><li><p>$e$ 不在任何一个圈中，$e$ 不为红色</p></li><li><p>$e$ 与 $f$ 在同一割中而在应用 blue rule 后被染成蓝色的是 $f$ ，$e$ 不为蓝色且 $w_e \geq w_f$  </p></li></ul>所以 $e$ 没有被染色，且 $w_e \geq w_f$ ，因此 $T^* \cup \{f\} \setminus \{e\}$  才应当是真实的 MST（权值更小），故 $f \in T^*$。</li></ul><p><em>Induction step 2:</em> 假设在应用 red rule 之前，<em>color invariant</em> 是正确的。</p><p>此时令 $C$ 为被选定的圈，$e$ 为被染成红色的边，则有以下两种情况：</p><ul><li>$e \notin T^*$ ，$T^*$ 满足 invariant。</li><li>$e \in T^*$ ，记 $T^*$ 在去掉 $e$ 后形成的割为 $D$ ，$f$ 为 $C \cap D$ 中的另一条边且  $f \notin T^*$（因为一个圈中的顶点都可以互相连通，故其中必有一条边不在所在图的生成树中）。因此，我们可以得到以下两条结论：<ul><li><p>$f \notin T^*$ ，$f$ 不为蓝色</p></li><li><p>$f$ 与 $e$ 在同一圈中而在应用 red rule 后被染成红色的是 $e$ ，$f$ 不为红色且 $w_f \leq w_e$</p></li></ul><p>所以 $f$ 没有被染色，且 $w_f \leq w_e$ ，故 $T^* \cup \{f\} \setminus \{e\}$  才应当是真实的 MST，因此我们证明了 $e \notin T^*$ 。</p></li></ul><p>因此，根据算法必定终止且终止时所有边皆会被染色，染成蓝色的边一定属于 $T^*$，染成红色的边一定不属于 $T^*$ ，我们证明了 <em>color invariant</em> 成立。所以所有蓝色的边组成了其所在图的 MST ，证毕。</p><h3 id="再探-Kruskal-和-Prim"><a href="#再探-Kruskal-和-Prim" class="headerlink" title="再探 Kruskal 和 Prim"></a>再探 Kruskal 和 Prim</h3><p>在引入了 red rule 和 blue rule 之后，我们可以发现 Kruskal’s algorithm 和 Prim’s algorithm 其实是这个推广的贪心算法的两个特例。Kruskal’s algorithm 和 Prim’s algorithm 可以分别被改写成如下形式：</p><h4 id="Kruskal’s-algorithm"><a href="#Kruskal’s-algorithm" class="headerlink" title="Kruskal’s algorithm"></a>Kruskal’s algorithm</h4><ul><li><p>查找未染色的权值最小的边，记为 $e$</p></li><li><p><em>Case 1:</em> 如果 $e$ 的两个顶点都在同一颗 blue tree 中，对某个 $e$ 所在的圈应用 red rule ，使得 $e$ 被染为红色</p><img src="/2018/12/22/dijkstra-mst-proof/kruskal_red.png" width="350" height="230" alt="Pittsburgh" align="center"><center><font color="#A9A9A9" size="2.5">Case 1</font></center></li><li><p><em>Case 2:</em> 否则应用 blue rule 到一个由所有 blue tree 顶点的形成的割中，使得 $e$ 被染成蓝色 </p><img src="/2018/12/22/dijkstra-mst-proof/kruskal_blue.png" width="350" height="230" alt="Pittsburgh" align="center"><center><font color="#A9A9A9" size="2.5">Case 2</font></center> </li></ul><h4 id="Prim’s-algorithm"><a href="#Prim’s-algorithm" class="headerlink" title="Prim’s algorithm"></a>Prim’s algorithm</h4><ul><li><p>记 $S$ 为由蓝色的边连接成的树中的顶点的集合</p></li><li><p>$S$ 可初始化为任意顶点</p></li><li><p>对由 $S$ 形成的割应用 blue rule</p><img src="/2018/12/22/dijkstra-mst-proof/prim.png" width="350" height="230" alt="Pittsburgh" align="center"><center><font color="#A9A9A9" size="2.5">Prim's algorithm</font></center> </li></ul><hr><p>以上就是对 Dijkstra’s algorithm 和最小生成树相关算法的全部证明。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1]Cornell University CS 2112 Course Notes. Retrieved from <a href="http://www.cs.cornell.edu/courses/cs2112/2018fa/recitations/13mst/rec13-18fa-mst.pdf" target="_blank" rel="noopener">http://www.cs.cornell.edu/courses/cs2112/2018fa/recitations/13mst/rec13-18fa-mst.pdf</a></p><p>[2]Princeton University COS 423 Lecture Notes. Retrieved from <a href="http://www.cs.princeton.edu/courses/archive/spr05/cos423/lectures/04mst.pdf" target="_blank" rel="noopener">http://www.cs.princeton.edu/courses/archive/spr05/cos423/lectures/04mst.pdf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Dijkstra’s algorithm 和寻找 minimum spanning tree (MST) 的相关算法都是图论中十分常用而又简洁易懂的算法，但其具体为什么有效仍需要在数学上进行证明。本文即介绍了对这两个大一数据结构课必讲算法的证明，出于我没有接受过正规的算法分析训练，如有纰漏或不严谨之处还望斧正。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Science" scheme="http://lixiuyu.cc/categories/Computer-Science/"/>
    
    
      <category term="Algorithm" scheme="http://lixiuyu.cc/tags/Algorithm/"/>
    
      <category term="Graph Theory" scheme="http://lixiuyu.cc/tags/Graph-Theory/"/>
    
  </entry>
  
  <entry>
    <title>Java wildcard capture 及相关问题</title>
    <link href="http://lixiuyu.cc/2018/12/19/java-unsound/"/>
    <id>http://lixiuyu.cc/2018/12/19/java-unsound/</id>
    <published>2018-12-18T17:23:03.000Z</published>
    <updated>2018-12-23T13:31:20.466Z</updated>
    
    <content type="html"><![CDATA[<p>之前 CS 2112 在讲 Java generics 的时候 Professor Kozen 提起过其实 Java 的 type system 是不牢靠的（unsound），并且他的同事 Ross Tate 曾专门为此发了<a href="https://dl.acm.org/citation.cfm?id=2984004" target="_blank" rel="noopener">一篇论文</a>。<a id="more"></a>出于学期中学业繁重，我并未能及时阅读，但一直没有忘记这回事，在回国的飞机上通读了一下（然而大部分并没有看懂），确实挺有意思。本篇文章即是对 Java generics 的 wildcard capture 特性以及为什么其会导致 Java type system unsound 的一个简单介绍，大部分内容来自该论文和 Ross Tate 所写的<a href="https://hackernoon.com/java-is-unsound-28c84cb2b3f" target="_blank" rel="noopener">相关博客</a>。</p><h2 id="Wildcard-Capture"><a href="#Wildcard-Capture" class="headerlink" title="Wildcard Capture"></a>Wildcard Capture</h2><p>在2004年发布的 Java 5 引入了<strong>泛型（generics）</strong>，即“<strong>参数多态（parametric polymorphism）</strong>”，使得一个方法可以接受不同类型的参数。比方说，<code>List&lt;E&gt;</code> 代表一个元素都为 type E 的 List。 而<strong>通配符 （wildcard）</strong>，用符号 <code>?</code> 表示，作为泛型方法参数时可以代表某种任意类型（具体类型无法在 compile time 判断，甚至有时在 run time 也无法判断）。例如 <code>List&lt;? extends Number&gt;</code> 表示一个元素可以是 Number 的任意子类的 List 。 </p><p>出于每一个 wildcard 可以表示某种类型，也可以是不同的类型，Java 使用了一种叫做 <strong>wildcard capture</strong> 的方式来对 wildcard 进行类型检测。通过引入一个 <strong>fresh type variable</strong> 来表示任意 wildcard 所描述的 unknown type，再对这个新的 type 进行类型检测，Java 可以实现对 wildcard 的类型检测。举个例子，对于方法 <code>&lt;E&gt; List&lt;E&gt; reverse(List&lt;E&gt; list) {...}</code>，开头的 <code>&lt;E&gt;</code> 表示这个方法可以应用于任意类型 E 。当 <code>ns</code> 为 <code>? extends Number</code> 类型时，  Java 会对 <code>reverse(ns)</code> 进行以下几步类型检测：</p><ol><li>判断 ns 是 <code>List&lt;? extends Number&gt;</code> 类型</li><li>因为这个类型有一个 wildcard 参数，引入一个 fresh type variable，X，来表示 wildcard</li><li>更改 wildcard 参数为 X，使得 <code>List&lt;? extends Number&gt;</code> 变为 <code>List&lt;X&gt;</code></li><li>检测 <code>reverse</code> 的参数类型是否为 <code>List&lt;X&gt;</code></li></ol><p>因此，<code>reverse(ns)</code> 将会返回一个类型为 <code>List&lt;X&gt;</code> 的结果。但仅仅通过这个结果，我们无法得知关于 X 的任何信息。事实上，除了以上的步骤，wildcard capture 还有以下两步来对 X 添加限制：</p><ul><li><p><strong>Explicit Constraint</strong> 在上例的 wildcard 中，<code>? extends Number</code> 表明该 wildcard 被限制为 Number 的子类。新引入的 fresh type variable，X，也被添加了必须是 Number 的子类的限制。所以根据这一 explicit constraint， JVM 知道任何 <code>List&lt;X&gt;</code> 的元素都是 Number 的子类。</p></li><li><p><strong>Implicit Constraint</strong> 有时除了 explicit constraint，wildcard 还会被添加一个比较隐式的限制。以下例子可以更好地帮助我们理解什么是 implicit constraint：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Numbers</span>&lt;<span class="title">N</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; <span class="keyword">extends</span> <span class="title">List</span>&lt;<span class="title">N</span>&gt; </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> N <span class="title">totalSumOfValues</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们有类型为 <code>Numbers&lt;?&gt;</code> 的参数 <code>nums</code> 作为 <code>reverse()</code> 的参数，对于结果 <code>reverse(nums)</code> 的类型 Y（新引入的 fresh type），我们知道些什么呢？因为 <code>Numbers&lt;?&gt;</code> 中的 <code>?</code> 可以是任意类型，我们无法从 explicit constraint 中得到任何信息。但我们从 <code>Numbers</code> 的定义中可以得知，任何一个 <code>Numbers</code> 的合法参数 <code>N</code> 都必须是 Number 的子类。我们称 <code>N</code> 被 implicitly 限制为 Number 的子类。所以我们 <code>Numbers&lt;?&gt;</code> 中的任意类型 <code>?</code> 也被加上了必须为 Number 子类的 implicit constraint。同样地，JVM 也得知 fresh type Y 也必定是 Number 的子类。</p></li></ul><p>以上就是对 Java generics 中的 wildcard capture 机制的介绍。</p><h2 id="何为-sound"><a href="#何为-sound" class="headerlink" title="何为 sound"></a>何为 sound</h2><p>大部分编程语言的 type systems 的目标是对一个 “well-typed” 的程序应该如何表现提供某种保证。比如，在大部分编程语言中，一个 well-typed 的程序对内存的使用应该是“安全”的。<strong>如果一个 type system 成功提供了这样的保证，那我们称这一 type system 是 “sound” 的</strong>。举一个最简单的例子，对 Java 而言，考虑以下伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">increment</span><span class="params">(Integer i)</span> </span>&#123; <span class="keyword">return</span> i + <span class="number">1</span>; &#125;</span><br><span class="line">String countdown = increment(“<span class="number">98765432</span>”);</span><br></pre></td></tr></table></figure><p>显然，Java 的 type system 会拒绝这段代码的执行（丢出一个 exception），因为 Java 的 type system 会保证如果一个方法要求的参数类型是 Integer，那么它接受的参数类型永远只能是 Integer，而不是 String 。在某些其他例子中，情况会稍微复杂一些：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; ints = Arrays.asList(<span class="number">1</span>);</span><br><span class="line">List raw = ints;</span><br><span class="line">List&lt;String&gt; strs = raw;</span><br><span class="line">String one = strs.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这段代码也是不应该被允许的，因为一个指定元素类型为 String 的 List 不应该可以得到一个类型为 Integer 的元素。然而，Java 在 compile time 并不会对这一段代码报错（本人也使用了 Intellij Java 10进行验证）。这是因为尽管在这个例子中这种情况显然是不好的，但在很多其他例子中，这样的一种“包容性”其实是有益处的。毕竟，<strong>“untyped languages are all about allowing bad things to happen so that more cool things can happen as well”</strong> 。不过，Java 在 runtime 执行 <code>get()</code> 指令时会再一次检测 List 中的元素是否为 String，从而发现本例中的代码应当被拒绝执行，并丢出相应的 exception （此处为 <code>ClassCastException</code>），避免出现安全问题。</p><h2 id="More-Unsoundness-in-Java"><a href="#More-Unsoundness-in-Java" class="headerlink" title="More Unsoundness in Java"></a>More Unsoundness in Java</h2><p>尽管在上例中 Java 在 runtime 成功发现了代码中的错误，没有在 type check 阶段就发现错误仍然是十分危险的。在 runtime 才丢出 Exception 只能说是运气好，因为如果历史变得稍有不同，比如 Java 在添加 generics 时不会检测类型的向后兼容性，或 Java 在第一次释出时就已经引入了 generics，<strong>那么这个 Exception 很有可能就不会被丢出，从而导致严重的安全隐患，例如在内存中访问了一个不存在的 field</strong> 。下面有一个更加复杂的例子来体现 Java 的 unsoundness：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unsound</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Constrain</span>&lt;<span class="title">A</span>, <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span>&gt; </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bind</span>&lt;<span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">    &lt;B extends A&gt;</span><br><span class="line">    <span class="function">A <span class="title">upcast</span><span class="params">(Constrain&lt;A,B&gt; constrain, B b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> b;  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> &lt;T,U&gt; <span class="function">U <span class="title">coerce</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    Constrain&lt;U,? <span class="keyword">super</span> T&gt; constrain = <span class="keyword">null</span>;</span><br><span class="line">    Bind&lt;U&gt; bind = <span class="keyword">new</span> Bind&lt;U&gt;();</span><br><span class="line">    <span class="keyword">return</span> bind.upcast(constrain, t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String zero = Unsound.&lt;Integer,String&gt;coerce(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了对以上代码进行 Type-argument inference ，Java 会先收集已知的假设和需要满足的要求，并根据这些限制条件来尝试决定是否存在一个合法的参数。在此例中，一共有以下的假设和需求：</p><img src="/2018/12/19/java-unsound/example1.png" width="460" height="140" alt="Pittsburgh" align="center"><p>首先 <code>Constrain&lt;U, ? super T&gt;</code> 中有一个 wildcard 参数，所以通过 wildcard capture，Java 引入了一个 fresh type variable，Z 。显然，这个 wildcard 有个 explicit constraint，即 T 是 Z 的子类。同时根据 <code>Constraint</code> 的定义 <code>Constrain&lt;A, B extends A&gt;</code> ，这里还有一个 implicit constraint，即 Z 是 U 的子类。由此可得 Assumption a) 和 b) 。接下来 Java 对 <code>bind.upcast(constrain, t)</code> 进行类型检测，此处的 <code>constrain</code> 为 <code>Constrain&lt;U, Z&gt;</code> ，类似地，由 <code>upcast</code>  的定义我们可以知道 B 在句法上等价于 Z ，同时 B 是 U 的子类，得到 c) 和 e) 。同样因为 <code>upcast</code> 的定义，<code>t</code> 的类型应当是 B 的子类，所以 T 是 B 的子类，得到 d) 。</p><p> 由于 c) 的存在，我们可以直接从 a) 和 b) 推出 d) 和 e) 成立。即，explicit constraint 告诉了我们 <code>t</code> 是一个合法参数，而 implicit constraint 使得 <code>bind.upcast</code> 满足要求。因此，使得 <code>coerce</code> 合法的关键在于找到一个具体的 Z ，其满足 <code>Constrain&lt;U, ? super T&gt;</code> 。然而，当 T 不是 U 的子类时，是不可能创造出这样的 <code>Constraint</code> 实例的（本例即是这种情况，Integer 显然 不可能是 String 的子类）。论文在这里引入了一个概念 <em>implicit null</em>，即 “in Java null inhabits <em>every</em> reference type”。所以，尽管不可能实例化 <code>Constrain&lt;U, ? super T&gt;</code> ，某些 “unsound” 的代码仍然可以通过 null 来通过 type check 的 assumption（因为本人对 type theory 知之甚少，也并不是特别理解这个解释，更无法进一步展开，还望各位读者在评论区指教）。因此理论上这段明显 “unsound” 的程序是满足所有需求的，也的确可以通过 javac, version 1.8.0_25 的编译。但其未能通过 Eclipse Compiler for Java, ecj version 3.11.1.v20150902-1521 和 Java 9, javac build 108 的编译，因为这两个更新的编译器首先考虑了 Requirements d) 和 e) ，并未建立 c)，并发现 t 的类型并不是 U 的子类，参数不合法$^1$。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p> 从以上例子可以得出，Java 的 type system 并不牢靠，有时会通过编译 “unsound” 的程序。论文中还给出了另外一个 eclipse 与 Java 9 也能通过编译的 “unsound” 程序，本文不进行展开$^2$。Java 中的 unsoundness 主要是源于引入泛型时的一些疏漏，比如本文所介绍的 wildcard capture 机制相关的几个例子。最后，引用 Professor Tate 写在博客中的一段话来总结为什么我们需要关注 type systems 中基本很少发生的 unsoundness：</p><blockquote><p>Soundness is a security guarantee, not a usability concern. What matters is if <em>someone</em> can write this, because then that someone can get around the security measures that people have placed their confidence in and do whatever they would like to do. In the case of soundness, it’s the malicious programmer you should be worried, not just you and your friends.</p></blockquote><hr><p><em>注 1</em> 在用 IntelliJ 测试时，编译器报了一个非常诡异的错误：Z 的范围不符合 <code>Constrain</code> 的要求，应当 extends U。然而，它又给出了 Z 的 upper bounds 和 lower bounds 分别是 U 和 T，的确是 U 的子类，令人十分费解。<br><em>注 2</em> 该可以通过所有三个编译器检测的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unsound9</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Type</span>&lt;<span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Constraint</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span>&gt; <span class="keyword">extends</span> <span class="title">Type</span>&lt;<span class="title">B</span>&gt; </span>&#123;&#125; </span><br><span class="line">    &lt;B&gt; Constraint&lt;? <span class="keyword">super</span> B&gt; bad() &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125; </span><br><span class="line">    &lt;B&gt; <span class="function">A <span class="title">coerce</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> pair(<span class="keyword">this</span>.&lt;B&gt;bad(), b).value; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Type&lt;T&gt; type;</span><br><span class="line">    T value;</span><br><span class="line">    Sum(Type&lt;T&gt; t, T v) &#123;</span><br><span class="line">      type = t;</span><br><span class="line">      value = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="function">Sum&lt;T&gt; <span class="title">pair</span><span class="params">(Type&lt;T&gt; type, T value)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Sum&lt;T&gt;(type, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> &lt;T,U&gt; <span class="function">U <span class="title">coerce</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    Type&lt;U&gt; type = <span class="keyword">new</span> Type&lt;U&gt;();</span><br><span class="line">    <span class="keyword">return</span> type.&lt;T&gt;coerce(t); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String zero = Unsound9.&lt;Integer,String&gt;coerce(<span class="number">0</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1]Nada Amin and Ross Tate. 2016. Java and scala’s type systems are unsound: the existential crisis of null pointers. <em>SIGPLAN Not.</em> 51, 10 (October 2016), 838-848. DOI: <a href="https://doi.org/10.1145/3022671.2984004" target="_blank" rel="noopener">https://doi.org/10.1145/3022671.2984004</a></p><p>[2]Tate, R. (2017, January 24). Java is Unsound: The Industry Perspective – Hacker Noon. Retrieved from <a href="https://hackernoon.com/java-is-unsound-28c84cb2b3f" target="_blank" rel="noopener">https://hackernoon.com/java-is-unsound-28c84cb2b3f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前 CS 2112 在讲 Java generics 的时候 Professor Kozen 提起过其实 Java 的 type system 是不牢靠的（unsound），并且他的同事 Ross Tate 曾专门为此发了&lt;a href=&quot;https://dl.acm.org/citation.cfm?id=2984004&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一篇论文&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Science" scheme="http://lixiuyu.cc/categories/Computer-Science/"/>
    
    
      <category term="Java" scheme="http://lixiuyu.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 Java String 类参数传递</title>
    <link href="http://lixiuyu.cc/2018/09/02/simple-java-fact/"/>
    <id>http://lixiuyu.cc/2018/09/02/simple-java-fact/</id>
    <published>2018-09-02T05:02:41.000Z</published>
    <updated>2018-12-21T13:26:57.653Z</updated>
    
    <content type="html"><![CDATA[<p>最近 CS 课正好在学 Java 的参数传递，本以为非常简单的内容却发现有诸多地方之前不甚明白，还是基本功不扎实啊（sigh）。本文所要讲的一个小发现就是我基础不扎实的佐证，但感觉还是挺有意思的，所以简单分享下。</p><a id="more"></a><p>观察以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"Hello"</span>;</span><br><span class="line">        String b = <span class="string">"Hello"</span>;</span><br><span class="line">        String a1 = <span class="keyword">new</span> String (<span class="string">"Hello"</span>);</span><br><span class="line">        String b1 = <span class="keyword">new</span> String (<span class="string">"Hello"</span>);</span><br><span class="line">        String c = a + <span class="string">"World"</span>;</span><br><span class="line">        String d = a + <span class="string">"World"</span>;</span><br><span class="line">        String e = <span class="string">"Hello"</span> + <span class="string">"World"</span>;</span><br><span class="line">        String f = <span class="string">"Hello"</span> + <span class="string">"World"</span>;</span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(a1 == b1);</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">        System.out.println(e == f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家觉得输出的结果应该是什么呢？很显然 <code>a1 == b1</code> 的结果应该是 <code>false</code>，由于是使用 <code>new</code> 创建的 <code>String</code>，a 和 b 是的地址是指向堆（<em>heap</em>）中对常量池（<em>constant pool</em>）的对象 “Hello” 的不同的拷贝对象地址。<code>a == b</code> 则应该是 <code>true</code>，因为它们是直接指向常量池中的同一个地址的（JVM 对于 String 的存储采用了常量池的机制，在这里不过多介绍）。</p><p>有趣的地方在于 <code>c == d</code> 和 <code>e == f</code>，他们的结果应该是什么，是否相同呢？其实 <code>c == d</code> 是 <code>false</code> 相对来说也算显然，毕竟 a 并不是一个常数，因此编译器无法判断 <code>a + &quot;world&quot;</code> 是否在常量池里面，只能在堆中直接创建 c 和 d 应该指向的地址，所以是不同的。但 <code>e == f</code> 结果却是 <code>true</code>，说明 “HelloWorld” 是在常量池里面的，并且 e 和 f 都指向其地址。但我们在之前并没有直接创建值为 “HelloWorld” 的 <code>String</code>，为什么 “HelloWorld” 会在常量池里面？这里就必须引入 <em>constant folding</em> 的概念，出于自己对编译原理知之甚少，直接搬运 <a href="https://en.wikipedia.org/wiki/Constant_folding?oldformat=true" target="_blank" rel="noopener"><em>Wikeapedia</em></a> 的介绍：</p><blockquote><p><strong>Constant folding</strong> is the process of recognizing and evaluating constant expressions at compile time rather than computing them at runtime. Terms in constant expressions are typically simple literals, such as the integer literal 2, but they may also be variables whose values are known at compile time. </p></blockquote><p>大部分编译器并不会产生运算的指令并等到 run time 在计算出结果，而是采用一种叫做 constant folding 的优化方法，在 compile time 的时候就分辨出语句结构，计算出结果。JVM 编译器也采用了 constant folding，在 compile time 的时候就把 <code>&quot;Hello&quot; + &quot;World&quot;</code> 处理成了 “HelloWorld”，所以 e 和 f 都指向了常量池中的 “HelloWorld” 而并没有在堆中新建对象。JVM 编译器实际上还采用了另外一个优化方法 <em>constant propagation</em>：</p><blockquote><p><strong>Constant propagation</strong> is the process of substituting the values of known constants in expressions at compile time. Such constants include those defined above, as well as intrinsic functions applied to constant values. </p></blockquote><p>理论上来说，因为 constant propagation，<code>a + &quot;world&quot;</code> 的结果也可以在 compile time 的时候计算出来。但对编译器而言，优化的程度和效率通常是不能兼顾的，而 JVM 编译器并没有在 String 相加的时候进行 constant propagation 的优化。</p><p>出于好奇，我又在 Python 上进行了一次实验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">"Hello"</span></span><br><span class="line">b = <span class="string">"Hello"</span></span><br><span class="line">c = a + <span class="string">"World"</span></span><br><span class="line">d = a + <span class="string">"World"</span></span><br><span class="line">e = <span class="string">"Hello"</span> + <span class="string">"World"</span></span><br><span class="line">f = <span class="string">"Hello"</span> + <span class="string">"World"</span></span><br><span class="line">print(a == b)</span><br><span class="line">print(c == d)</span><br><span class="line">print(e == f)</span><br></pre></td></tr></table></figure><p><code>a == b</code> 显然正确，不多提。<code>e == f</code> 也是正确的，看来 Python 编译器也使用了 <code>constant folding</code> 进行优化。然而奇怪的是，<code>c == d</code> 居然也是正确的？难道 Python 对于 String 的储存机制有什么特别之处？但我在运行 <code>id(c)</code> 和 <code>id(d)</code> 之后发现 c 和 d 的地址并不相同。原来 Python 中对于 String 的 <code>==</code>  其实是比较两个 String 的值是否相同，相当于 Java 的 <code>.equals()</code>，实在是坑爹。在运行 <code>print(c is d)</code> 之后，果然得到了 <code>false</code> 的结果。</p><p>这个文章可以说是非常 trivial 了，也暴露了自己学艺不精，权当茶余饭后巩固知识的小科普一篇。希望以后可以专注于一些更有趣的问题，产出一些高质量的文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近 CS 课正好在学 Java 的参数传递，本以为非常简单的内容却发现有诸多地方之前不甚明白，还是基本功不扎实啊（sigh）。本文所要讲的一个小发现就是我基础不扎实的佐证，但感觉还是挺有意思的，所以简单分享下。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Science" scheme="http://lixiuyu.cc/categories/Computer-Science/"/>
    
    
      <category term="Java" scheme="http://lixiuyu.cc/tags/Java/"/>
    
      <category term="Compilers" scheme="http://lixiuyu.cc/tags/Compilers/"/>
    
  </entry>
  
  <entry>
    <title>TechX 2018总结</title>
    <link href="http://lixiuyu.cc/2018/08/24/TechX-2018/"/>
    <id>http://lixiuyu.cc/2018/08/24/TechX-2018/</id>
    <published>2018-08-24T15:00:00.000Z</published>
    <updated>2018-12-23T02:54:56.996Z</updated>
    
    <content type="html"><![CDATA[<p>时隔两年，我在高三暑假又一次去上海参加了 TechX 科技峰会，也有了一些新的体会与感触。</p><img src="/2018/08/24/TechX-2018/slogan.jpg" width="760" height="180" alt="Pittsburgh" align="center"><center><font color="#A9A9A9" size="2">TechX 2018 Slogan</font></center><a id="more"></a><h2 id="关于课程"><a href="#关于课程" class="headerlink" title="关于课程"></a>关于课程</h2><p>这一次我报的课程是深度强化学习，总体来说学的东西还是比较硬核的。比起2016年的 <em>Machine Learning</em>，这次的课程更加注重数学推导与算法实现而非 libraries 的应用，诸如 Back Propogation, Q-learning, Multi-armed Bandit 之类的模型和算法都会详细推导并布置相应的编程实现习题。不过进度和内容的确有些太快太深，上完课很多东西还是没有弄懂，因此对于高中生而言难度可能是有些偏高。但反过来讲，吃透了这门课的内容个人认为对机器学习和强化学习也算是初窥门径了，因此这门课还是收获颇多，非常值得一上。</p><p>我把部分课后习题的代码上传到了 <a href="https://github.com/lxywizard/techx-drl-homework" target="_blank" rel="noopener">Github</a>，感兴趣的读者可以看下，但注释和风格都没有注意，见笑了。</p><p>Seminars 也听了不少，有一些还是挺有意思的，比如 Karen 学姐的自然语言处理和一个密码学相关的学术性很强，有不少干货，Intel 工程大赛中国队员的分享也好好膜拜了一波（同个高中的学妹也在里面orz）。诸如华为区块链的讲座就让我有点昏昏欲睡了，聊天机器人和爬虫什么的也是网上看看教程轻易就可以入门，不过考虑到 TechX 也有挺多零基础的学员，激发他们对技术的兴趣这些东西也更加合适一点，就见仁见智，不做评论了。</p><h2 id="关于-Hackathon"><a href="#关于-Hackathon" class="headerlink" title="关于 Hackathon"></a>关于 Hackathon</h2><p>TechX 2018 的 hackathon 策划的还是比较成功的，从一开始就有各种活动帮助大家策划最后的 hackathon project。我这次的项目是一个识别、介绍、推荐、生成不同文化的代表图案纹理的 IOS app，并且又苦逼的选择了自己训练模型（毕竟这种奇葩主题怎么会有 pre-trained model 嘛 qwq）。。。果然数据集又是不够，差点重蹈了2016年的覆辙，还好后来在几个组员拼命人工筛选 Google 爬下来质量堪忧的图片（各位组员真的辛苦了，手动从上千张图片找不合格的眼睛也太难受了），我也写了不少 python 脚本来批量做数据增强，弄了5个类别，每个类别几千张图，丢到一个去掉全连接层的基于 ImageNet 的 InceptionV3 模型里。在 n 次调参之后也有超过 95 % 的正确率（我是不会说只有 tartan 一个分类用实拍照片测是真的有这种正确率的）。还好最后 IOS app 做的还算比较好看，成功 carry 我们进入十六强。总而言之这次 hackathon 说不上满意，但中规中矩吧，最大的收获就是迁移学习应用和一些调参的技巧了（捂脸）。</p><img src="/2018/08/24/TechX-2018/hackathon.jpeg" width="760" height="180" alt="Pittsburgh" align="center"><center><font color="#A9A9A9" size="2">hackathon project “纹” demo</font></center><p>具体代码在<a href="https://github.com/lxywizard/TechX-Texture" target="_blank" rel="noopener">这里</a>，其实推荐系统还没有做好，也还没有把生成图案的功能加到 app 里去，但能够做展示的核心代码都在这了（逃</p><h2 id="一点感想"><a href="#一点感想" class="headerlink" title="一点感想"></a>一点感想</h2><p>TechX 是一个充满理想主义的地方，人们可以在这里感受到对科技的最纯粹的热爱，这一点是令我、也是令很多人非常意外的。相对很多所谓的“高水平”夏校而言，TechX 说不上 selective 参加的人水平也良莠不齐，然而它就是可以营造出这种大家都抛开面子，无论问题简单与否，都积极不耻下问；无论 idea 是否看上去 naive，都能放上台面上来讨论的开放的氛围，这些都是我们以往很少能看见的。关于这点，我也在知乎上写了一个<a href="https://www.zhihu.com/question/60409263/answer/464998561" target="_blank" rel="noopener">非常感性的答案</a>（想看感想的话这个答案干货比此文多得多）。</p><p>现在过去了这么久也可以更为理性的审视 TechX，当然创立 TechX 的初衷是否真的如同所宣传的那样理想化我们也不得而知，我也并没有因为 TechX 而整个人就变得纯粹理想主义起来。但 TechX 的经历确实给了我相当大的感触，我本人也自诩为一个“披着披着理想主义者外衣的现实主义者外衣的理想主义者”，因此这个活动也给了我一个审视自己未来道路的契机，在理想和现实之间到底如何抉择。无论如何，不管在 TechX 之外大家是怎么样的，如果各位心中尚有着对纯粹交流科技的渴望，都尽管可以来参加，因为至少在 TechX 的十天里，确实能够给大家一个相当完美的理想主义氛围。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时隔两年，我在高三暑假又一次去上海参加了 TechX 科技峰会，也有了一些新的体会与感触。&lt;/p&gt;
&lt;img src=&quot;/2018/08/24/TechX-2018/slogan.jpg&quot; width=&quot;760&quot; height=&quot;180&quot; alt=&quot;Pittsburgh&quot; align=&quot;center&quot;&gt;

&lt;center&gt;&lt;font color=&quot;#A9A9A9&quot; size=&quot;2&quot;&gt;TechX 2018 Slogan&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://lixiuyu.cc/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="活动" scheme="http://lixiuyu.cc/tags/%E6%B4%BB%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>一道有趣的行列式习题的探究</title>
    <link href="http://lixiuyu.cc/2018/05/01/interesting-determinant-question/"/>
    <id>http://lixiuyu.cc/2018/05/01/interesting-determinant-question/</id>
    <published>2018-05-01T15:22:44.000Z</published>
    <updated>2018-09-08T21:27:55.603Z</updated>
    
    <content type="html"><![CDATA[<p>上周五在世史课上做柯斯特利金的代数学引论第一章的习题时，发现了一道有趣的问题：</p><p><strong>证明在三阶行列式展开式中的六项不可能同时为正。</strong></p><p>当时我的第一反应是通过分类讨论来证明六项为正的情况不存在，然而暴力枚举三阶行列式9个元素的所有正负性的情况一共有$2^9 = 512$种组合，不可能通过手算得出。于是我便开始认真思考这个问题，并最后探究出了以下几个有趣的方法和结论。<a id="more"></a></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>首先我还是想继续直观地暴力枚举，试图寻找一些可行的分类方法来降低复杂度。我先从一个三阶行列式 $\det A$ 的计算公式中观察规律：</p><p>\begin{align}<br>\det A &amp;=<br>\begin{vmatrix}<br>a &amp; b &amp; c \\<br>d &amp; e &amp; f \\<br>g &amp; h &amp; i<br>\end{vmatrix}<br>= a(ei - fh) - b(di - fg) + c(dh - eg) = aei + bfg + cdh - afh - bdi - ceg<br>\end{align}</p><p>此时我发现可以通过假设存在全部6项为正的情况，讨论 $a，b，c$ 三项正负性的所有情况，并根据 $a，b，c$ 求出其他项的正负性，继而可得除 $a，b，c$ 外其他元素的同异号关系。如果不论 $a，b，c$ 正负性如何，均存在同异号矛盾则命题得证。由于其他项仅由两个元素相乘，判断同异号关系较为容易。$a，b，c$ 所有正负性情况也只有$2^3 = 8$种情况，而且其中4种情况与剩下4种情况正负性完全相反，根据对称性，在这4种情况中若余下元素的同异号关系产生矛盾，则剩下4种情况同样会出现矛盾。因此，我们只需要讨论4种情况即可，其结果如下表所示：</p><table><thead><tr><th></th><th align="center">$ei$</th><th align="center">$fg$</th><th align="center">$dh$</th><th align="center">$fh$</th><th align="center">$di$</th><th align="center">$eg$</th></tr></thead><tbody><tr><td>$a,b,c&gt;0$</td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td>$a,b&gt;0$, $c&lt;0$</td><td align="center">+</td><td align="center">+</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">+</td></tr><tr><td>$a&gt;0$, $b,c&lt;0$</td><td align="center">+</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">+</td><td align="center">+</td></tr><tr><td>$a,c&gt;0$, $b&lt;0$</td><td align="center">+</td><td align="center">-</td><td align="center">+</td><td align="center">-</td><td align="center">+</td><td align="center">-</td></tr></tbody></table><center><font color="#A9A9A9" size="2">Conditions when all 6 terms are positive</font></center>通过观察表格可以发现，在所有4种情况中除 $a, b, c$ 外的元素的同异号关系均产生矛盾，具体如下：<ul><li>当 $a,b,c&gt;0$ 时，$i$ 和 $g$ 异号，$g$ 和 $h$ 异号，$h$ 和 $i$ 异号，矛盾</li><li>当 $a,b&gt;0$，$c&lt;0$ 时，$g$ 和 $h$ 异号，$h$ 和 $i$ 同号，$i$ 和 $g$ 同号，矛盾</li><li>当 $a&gt;0$，$b,c&lt;0$ 时，$f$ 和 $e$ 异号，$e$ 和 $d$ 同号，$d$ 和 $f$ 同号，矛盾</li><li>当 $a,c&gt;0$，$b&lt;0$ 时，$d$ 和 $f$ 异号，$f$ 和 $e$ 同号，$e$ 和 $d$ 同号，矛盾</li></ul><p>由此可得，三阶行列式展开式中的六项不可能同时为正。为了验证我们的结果，我又写了一个程序来重新暴力枚举一遍所有情况。出于512这个总数对于计算机而言还算小，我就直接无脑写了一个时间复杂度 $\mathcal{O}(n^9)$ 的嵌套循环来达到我们的目的（当然如果有效率更高或可以拓展到 $n$ 阶的代码欢迎各位读者提出）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算三阶行列式的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">determinant3</span><span class="params">(a, b, c, d, e, f, g, h, i)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a * e * i + b * f * g + c * d * h - a * f * h - b * d * i - c * e * g</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 枚举并判断是否存在六项全部为正的情况的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whetherAllPostive</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 每个元素只取-1和1来表示正负</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">-1</span>, <span class="number">2</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">-1</span>, <span class="number">2</span>, <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">-1</span>, <span class="number">2</span>, <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">for</span> d <span class="keyword">in</span> range(<span class="number">-1</span>, <span class="number">2</span>, <span class="number">2</span>):</span><br><span class="line">                    <span class="keyword">for</span> e <span class="keyword">in</span> range(<span class="number">-1</span>, <span class="number">2</span>, <span class="number">2</span>):</span><br><span class="line">                        <span class="keyword">for</span> f <span class="keyword">in</span> range(<span class="number">-1</span>, <span class="number">2</span>, <span class="number">2</span>):</span><br><span class="line">                            <span class="keyword">for</span> g <span class="keyword">in</span> range(<span class="number">-1</span>, <span class="number">2</span>, <span class="number">2</span>):</span><br><span class="line">                                <span class="keyword">for</span> h <span class="keyword">in</span> range(<span class="number">-1</span>, <span class="number">2</span>, <span class="number">2</span>):</span><br><span class="line">                                    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">-1</span>, <span class="number">2</span>, <span class="number">2</span>):</span><br><span class="line">                                        <span class="comment"># 当且仅当六项全部为正的情况下，三阶行列式值为6；若存在该情况，返回六个元素的值并判定存在</span></span><br><span class="line">                                        <span class="keyword">if</span> determinant3(a, b, c, d, e, f, g, h, i) == <span class="number">6</span>:</span><br><span class="line">                                            <span class="keyword">return</span> <span class="string">"There exists %d %d %d %d %d %d %d %d %d so that all terms are positive."</span>%(a, b, c, d, e, f, g, h, i)</span><br><span class="line">    <span class="comment"># 否则判定不存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Such condition does not exist."</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用该函数并输出结果</span></span><br><span class="line"><span class="keyword">print</span> (whetherAllPostive())</span><br></pre></td></tr></table></figure><p>而最后的输出结果也的确是不存在六项全为正的情况。然而，在我进一步分别把从-6到5的整数都代入到<code>determinant3(a, b, c, d, e, f, g, h, i)</code>相等的条件中，发现当每个元素为-1或1时，<strong>三阶行列式的值只能是-4，0，4</strong>。这是怎么回事呢？想要解释这一点，有必要进一步拓展到$n$阶的情况下进行代数证明。</p><h2 id="代数"><a href="#代数" class="headerlink" title="代数"></a>代数</h2><p>一个 $n$ 阶行列式 $\det A$ 的值是由其中一行的 $n$ 个元素分别乘上它们的代数余子式再相加得到。因此，我们从二阶行列式往上推，很容易可以通过数学归纳法得到 $n$ 阶行列式的展开式有 $n!$ 项，同时每一项由 $n$ 个元素相乘得到，具体推导就不在这里展开。如果我们把展开式的每一项乘起来，就会得到一个有 $n\cdot n!$ 项相乘的式子。这个式子还要乘上一个因子$(-1)^\frac{n!}{2}$，因为根据代数余子式的定义（$i$ 行 $j$ 列对应的项的代数余子式要乘一个系数$(-1)^{i + j}$），有一半的项带有一个系数$-1$。</p><p>实际上，$n$ 阶行列式的每一个元素在其展开式中出现了 $(n-1)!$ 次，因为若取某任意一个元素，其对应要乘上的代数余子式都有 $(n-1)!$ 项。而我们可以取任意一行或一列来求代数余子式计算 $n$ 阶行列式，最后得出的展开式不变。由此可得，在 $n$ 阶行列式的展开式中，原行列式每一个元素都出现了 $(n-1)!$ 次。从这种角度看，原来的 $n\cdot n!$ 项可被表示为 $n\cdot n\cdot (n-1)!$ 项，而展开式的所有项的乘积也可以得出：</p>\begin{align}Product\ of\ all\ terms\ of\ \det A &= a_{11}^{(n-1)!}\cdot a_{12}^{(n-1)!}\cdot\ldots\cdot a_{nn}^{(n-1)!}\cdot (-1)^\frac{n!}{2}\\\\&=(a_{11}\cdot a_{12}\cdot\ldots\cdot a_{nn})^{(n-1)!}\cdot (-1)^\frac{n!}{2}\end{align}<p>因为当 $n\geq2$ 时，$(n-1)!$ 永远是偶数，$(a_{11}\cdot a_{12}\cdot\ldots\cdot a_{nn})^{(n-1)!}$ 的值恒为正。所以展开式所有项乘积的正负性由$(-1)^{\frac{n!}{2}}$决定。当 $n=3$ 时（即三阶行列式的情况），$(-1)^\frac{n!}{2}=-1$，展开式所有项乘积小于0。因此，在三阶行列式的展开式中负数项的个数只能是奇数。出于三阶行列式展开式共有六项，负数项个数只可以取1，3，5。当行列式每个元素只取-1和1时，对应的行列式的值则分别为4，0，-4。因此只存在<code>determinant3(a, b, c, d, e, f, g, h, i)</code>等于4，0，-4时的情况。</p><h2 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h2><p>除了用枚举和代数推导，实际上还可以通过行列式的几何意义来证明为什么三阶行列式展开式的六项不能同时为正。不过本人对这一方面涉猎不多，所需背景知识也相对较多，本文只简单拓展一下。此部分内容主要参考<a href="https://ccjou.wordpress.com/2013/09/12/%e9%98%bf%e9%81%94%e9%a6%ac%e7%9a%84%e6%9c%80%e5%a4%a7%e8%a1%8c%e5%88%97%e5%bc%8f%e5%95%8f%e9%a1%8c/" target="_blank" rel="noopener">阿達馬的最大行列式問題</a>这篇文章。</p><p>对于 $n\times n$ 阶矩阵 $A$，$|\det A|$ 等于 <strong>$A$ 的列向量（或行向量）于 $\mathbb{C}^n$ 空间所张开的平行（超）多面体体积</strong>。这就是行列式的几何意义，本篇文章不在这里进行证明。</p><p><img src="/2018/05/01/interesting-determinant-question/determinant_3d.png" alt=""></p><center><font color="#A9A9A9" size="2">$3\times 3矩阵列向量所张开的多面体$</font></center>我们把每一个列向量当做平行多面体的边，可以发现当所有列向量两两正交时，平行多面体体积最大，为各方向边长的乘积（这一点在二维的情况下可以直观地看出，当平行四边形是矩形时，也就是两边垂直（代表边的向量正交）时，面积最大，为两个不同方向的边长的乘积。推广到高维同样适用）。这一几何性质可以用一个不等式描述:<center>$|\det A|\leq\prod\limits_{j=1}^{n}||\boldsymbol{a}_j||$</center><p>其中 $\boldsymbol{a}<em>j$ 代表矩阵 $A$ 的列向量，$||\boldsymbol{a}_j||^2=\sum\limits_{i=1}^n|a_{ij}|^2$。这个不等式被称为 <a href="https://www.wikiwand.com/en/Hadamard's_inequality" target="_blank" rel="noopener"><strong>Hadamard 不等式</strong></a>。我们继续沿用只给矩阵的元素取-1和1的方法。假设 $n$ 阶行列式的展开式可以所有项同时为正，那么行列式最大值为 $n!$（展开式一共有 $n!$ 项），也即$n \times n$矩阵表示的平行多面体体积最大值为 $n!$。而当每个元素都为1或-1时，易得 $||\boldsymbol{a}_j||^2=\sum\limits_{i=1}^n|a_{ij}|^2=n$。由此可得 $||\boldsymbol{a}_j||=\sqrt{n}=n^\frac{1}{2}$，$\prod\limits_{j=1}^{n}||\boldsymbol{a}_j||=n^\frac{n}{2}$。因此根据 Hadamard 不等式，$n\times n$ 矩阵表示的平行多面体体积最大值为 $n^\frac{n}{2}$。我们可以证明当 $n&gt;2$ 时，$n^\frac{n}{2} &lt; n!$（证明略；可以通过数学归纳法或证明 $\lim\limits</em>{n\to\infty}\frac{n^\frac{n}{2}}{n!}$ 收敛），所以在 $n&gt;2$ 时，$n\times n$ 矩阵所表示的平行多面体体积必定小于 $n!$，即 $n$ 阶行列式的展开式不可能同时为正。</p><p>通过关于行列式的几何意义的方法，我们不仅证明了三阶行列式的展开式不可能同时为正，也推广到了当 $n&gt;2$ 时，$n$ 阶行列式的展开式不可能同时为正。</p><hr><p>这篇文章虽然讨论的问题和涉及的方法都比较 trivial，但我个人觉得这个问题还是挺有趣的，如果各位有新的方法或者对本文的内容有什么不清楚的地方还请在评论区或通过其他方式与我多多交流。很久没有更文了（接近荒废），就暂时先这样水一篇吧。近期时间逐渐变得充裕，应该会开始稍微频繁一点写blog（如果没有就是我又继续咸鱼了qaq）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周五在世史课上做柯斯特利金的代数学引论第一章的习题时，发现了一道有趣的问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明在三阶行列式展开式中的六项不可能同时为正。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当时我的第一反应是通过分类讨论来证明六项为正的情况不存在，然而暴力枚举三阶行列式9个元素的所有正负性的情况一共有$2^9 = 512$种组合，不可能通过手算得出。于是我便开始认真思考这个问题，并最后探究出了以下几个有趣的方法和结论。&lt;/p&gt;
    
    </summary>
    
      <category term="Math" scheme="http://lixiuyu.cc/categories/Math/"/>
    
    
      <category term="Linear Algebra" scheme="http://lixiuyu.cc/tags/Linear-Algebra/"/>
    
  </entry>
  
  <entry>
    <title>AP统计中几个知识点的解释</title>
    <link href="http://lixiuyu.cc/2018/01/25/stat/"/>
    <id>http://lixiuyu.cc/2018/01/25/stat/</id>
    <published>2018-01-25T03:11:27.000Z</published>
    <updated>2018-12-23T02:49:45.240Z</updated>
    
    <content type="html"><![CDATA[<p>去年在学习AP <del>TI-84/NSPIRE艺术</del>统计时，总有一些骚操作让人一头雾水。而每当询问Mr. Z时，他也只是会说“This is an AP level course. You only need to know how to press the calculator.” 本篇文章讨论了几个AP统计中涵盖的公式及比较有意思的知识点背后的原理。</p><a id="more"></a><p><em>注：本篇文章大部分专业词汇使用英文，以便于读者将它们与AP统计中所学的概念相对应，若对中英文夹杂感到不适还请见谅</em></p><h2 id="Sample-Variance-Formula"><a href="#Sample-Variance-Formula" class="headerlink" title="Sample Variance Formula"></a>Sample Variance Formula</h2><p>在学习sample variance的时候，我对于其计算公式</p><center>$$ s_x^2=\frac{1}{n-1}\sum{(x_i-\bar{x})^2}$$</center><p>中的$n-1$（而不是$n$）非常不解，而在课本<em>The Basic Practice of Statistics for AP</em> 431页单纯通过举例子计算的解释显然是一点帮助也没有。。。不过其提到的一个词<em>biased estimator</em>却的确是问题的关键：</p><p><strong>当我们有一个参数为实数$\theta$的概率模型，构造关系$u$，若对任意观测数据$X$，都有</strong></p><center>$E[u(X_1,X_2,\ldots,X_n)]=\theta$</center><p><strong>则我们称 $u(X_1,X_2,\ldots,X_n)$ 是一个对 $\theta$ 的 _unbiased estimator_。否则，$u(X_1,X_2,\ldots,X_n)$ 是一个对 $\theta$ 的 <em>biased estimator</em></strong></p><p>对于任意一个服从分布$F$的随机变量$X$，已知$X$的期望为$\mu$，则随机变量$X$或分布$F$的真实方差为</p><center>$Var(X) = \sigma^2=E[(X-\mu)^2]$</center><p>由此可得</p><center>$\displaystyle Var(X)=\sigma^2=E[\frac{1}{n}\sum_{i=1}^{n}(X_i - \mu)^2]$</center><p>这一个$E[\frac{1}{n}\sum_{i=1}^{n}(X_i - \mu)^2]$就是对真实方差的一个<em>unbiased estimator</em>。而在计算sample variance中，当直接以$n$作为分母时，所得出的sample variance却是对$Var(X)$的一个<em>biased estimator</em>，并不是我们真正想要的方差。这是因为我们在计算时并不知道$X$的期望$\mu$，只能用样本均值$\bar{X}$代替（本质原因是样本均值$\bar{X}$是期望$\mu$的<strong>ordinary least squares</strong>，本篇文章不对此进行深入展开）。若以$n$为分母计算sample variance $s_x^{‘2}$，则会有</p>\begin{align} E[s_x^{'2}] &= E[\frac{1}{n}\sum_{i=1}^{n}(X_i - \bar{X})^2]\\\\&= E[\frac{1}{n}\sum_{i=1}^{n}(X_i - \mu + \mu - \bar{X})^2]\\\\&= E[\frac{1}{n}\sum_{i=1}^{n}(X_i - \mu - (\bar{X} - \mu))^2]\\\\&= E[\frac{1}{n}\sum_{i=1}^{n}((X_i - \mu)^2 - 2(X_i - \mu)(\bar{X}-\mu) + (\bar{X}-\mu)^2))]\\\\&= E[\frac{1}{n}(\sum_{i=1}^{n}(X_i - \mu)^2 - 2n(\bar{X} - \mu)(\bar{X}-\mu) + n(\bar{X}-\mu)^2)]\\\\&= E[\frac{1}{n}\sum_{i=1}^{n}(X_i - \mu)^2] - E[\frac{1}{n}*n(\bar{X}-\mu)^2]\\\\&= \frac{1}{n}E[\sum_{i=1}^{n}(X_i - \mu)^2] - \frac{1}{n}*nE[(\bar{X}-\mu)^2]\\\\&= \frac{1}{n}(nVar(X) - nVar(\bar{X}))\\\\&= Var(X) - Var(\bar{X})\end{align}<p>而sample mean的方差为$\sigma_M^2=\frac{\sigma^2}{n}$（这个公式也可以从课本中的standard deviation of $\bar{X}$中推出）。因此，我们有</p><center>$E[s_x^{'2}]=\sigma^2-\frac{\sigma^2}{n}=\frac{(n-1)\sigma^2}{n}$</center><p>由此可得，当分母为$n$时，计算出的sample variance是真实方差的<em>biased estimator</em>，而将分母变回$n-1$时，$s_x^2$的期望则是</p><center>$E[s_x^2]=\frac{1}{n-1}(nVar(X) - nVar(\bar{X}))=\frac{n}{n-1}\frac{(n-1)\sigma^2}{n}=\sigma^2$</center><p>所以$ s_x^2=\frac{1}{n-1}\sum{(x_i-\bar{x})^2}$是对sample variance的<em>unbiased estimator</em>。将原来的$biased$的$E[s_x^{‘2}]$变为$unbiased$的$E[s_x^2]$所乘的系数$\frac{n}{n-1}$被称为<strong>Bessel’s correction</strong>。</p><h2 id="Control-of-Type-II-Error"><a href="#Control-of-Type-II-Error" class="headerlink" title="Control of Type II Error"></a>Control of Type II Error</h2><p>做过AP统计significance test这一章选择题的各位都知道，如果想要减小假设检验发生Type II error (when it fails to reject a null hypothesis $H_0$ that really is false)的概率，可以使用增大样本容量（increase sample size）的方法。但书上和统计老师都并未对这样做的原理进行解释。本节将会提供两个对在<em>z test</em>中通过增大样本容量降低Type II error发生概率的解释。</p><h3 id="Explanation-I"><a href="#Explanation-I" class="headerlink" title="Explanation I"></a>Explanation I</h3><p>第一个解释比较直观。举一个简单例子，现在要估算HFI学生在上一次统计考试中的平均成绩，我们的null hypothesis ($H_0$)是平均成绩为$\mu_1$，即上次考试中学生成绩符合正态分布（Normal distribution）$N(\mu_1, \sigma^2)$。而我们的alternative hypothesis ($H_1$)是平均成绩为大于$\mu_1$的某个值，设该值为$\mu_2$，也就是说学生成绩符合正态分布$N(\mu_2, \sigma^2)$。</p><p>当我们随机选取$n$个学生计算他们的平均成绩$\bar{X}$，再通过$z = \frac{\bar{X}-\mu_1}{\sigma/\sqrt{n}}$计算出<em>z score</em>与对应的<em>P-value</em>，即可根据<em>P-value</em>推断学生的平均成绩是$\mu_1$还是$\mu_2$（即接受或拒绝$H_0$）。而由<em>z score</em>的计算公式可以得知，$\bar{X}$的位置决定抽样学生成绩属于正态分布$N(\mu_1, \frac{\sigma^2}{n})$还是$N(\mu_2, \frac{\sigma^2}{n})$。</p><p>因此，若在下图中x轴上$\alpha$ (significance level)对应的<em>z score</em>处有一点$k$，则当$\bar{X}&lt; k$时接受$H_0$，当$\bar{X}&gt;k$时拒绝$H_0$（若相等则增大样本容量重新计算）。</p><p><img src="/2018/01/25/stat/mean.png" alt=""></p><p>这个时候可得Type II error的概率就是$P(N(\mu_2,\frac{\sigma^2}{n})&lt;k)$，即落在k左边的$N(\mu_2, \frac{\sigma^2}{n})$部分的面积。当样本容量（$n$）增大的时候，$\frac{\sigma^2}{n}$减小，因此$\mu_1$和$\mu_2$所在分布的range都会减小，也就是说两个分布的图像都会分别以$\mu_1$和$\mu_2$为中心“变窄”。此时对于同样的<em>z score</em>代表的$k$，$P(N(\mu_2,\frac{\sigma^2}{n})&lt;k)$会减小（因为面积减小），即Type II error减小。</p><p>这就是一个对于增大本容量降低Type II error发生概率的解释。不过，用观察图像来解释原理实在是不够让人信服，连一个严谨的数学证明都没有</p><p><img src="/2018/01/25/stat/%E5%9D%91%E7%88%B9.jpg" alt=""></p><p>对于这一样本容量与Type II error发生概率的关系，是否可以通过数学公式证明呢？</p><p><img src="/2018/01/25/stat/%E7%BB%99%E5%8A%9B.jpg" alt=""></p><p>当然可以，下面就来看看第二个更为严谨的解释。</p><h3 id="Explanation-II"><a href="#Explanation-II" class="headerlink" title="Explanation II"></a>Explanation II</h3><p>若要通过数学证明来解释样本容量与Type II error发生概率的关系，我们需引入施行特征函数：</p><p><strong>若$C$是参数$\theta$的某检验问题的一个检验法，</strong></p><p><strong><center>$\beta(\theta)=P_\theta(接受H_0)$</center></strong></p><p><strong>称为检验法$C$的施行特征函数或<em>OC</em>函数</strong></p><p>因此，当$\theta \in H_1$时，$\beta(\theta)$就是发生Type II error的概率。在这个时候$1 - \beta(\theta)$就是做出正确判断（拒绝$H_0$）的概率。函数$1 - \beta(\theta)$被称为检验法$C$的<strong>power function</strong>，在这里不深入探究。本文主要介绍通过<em>OC</em>函数来证明增大本容量可以降低Type II error的发生概率。</p><p>我们假设有$H_0: \mu &lt; \mu_0$和$H_1:\mu&gt;\mu_0$，即对$H_0$和$H_1$进行一个<em>one-sided z test</em>。对此，我们有<em>OC</em>函数</p><center>$\beta(\mu) = P_\mu(接受H_0)=P_\mu(\frac{\bar{X}-\mu_0}{\sigma/\sqrt{n}} < z_\alpha)=P_\mu(\frac{\bar{X}-\mu}{\sigma/\sqrt{n}} < z_\alpha-\frac{\mu-\mu_0}{\sigma/\sqrt{n}})$</center><p>此处$z_\alpha$即为$\alpha$ (significance level)对应的<em>z score</em>，而由于$\frac{\bar{X}-\mu}{\sigma/\sqrt{n}} $正好是任意样本均值$\bar{X}$于正态分布$N(\mu,\frac{\sigma^2}{n})$的<em>z score</em>，可以得到</p><center>$\beta(\mu)=\phi(z_\alpha - \lambda)$</center><p>$\lambda$为$\frac{\mu-\mu_0}{\sigma/\sqrt{n}}$，而$\phi$则代表正态分布$N(\mu,\frac{\sigma^2}{n})$的<strong>分布函数（Cumulative Distribution Function, CDF）</strong>，即正态分布<strong>概率密度函数（Probability Density Function, PDF）的变上限积分</strong>。因此，我们有</p><center>$\beta(\mu) =\phi(z_\alpha - \lambda)=\frac{1} {\sqrt{2\pi}}\int_{-\infty}^{z_\alpha - \lambda}e^{-x ^{2}/2}dx$</center><p>当$\beta(\mu)$代表发生Type II error的概率时，此时正确的应是$H_1$，也就是$\mu&gt;\mu_0$，所以$\mu-\mu_0&gt;0$，增大样本容量$n$会令$\frac{\mu-\mu_0}{\sigma/\sqrt{n}}$，也即$\lambda$增大。因此$\lambda$对$n$<strong>单调递增</strong>。而当$\lambda$增大时，积分上界$z_\alpha - \lambda$随之减小，所以$\beta(\mu)$对于$\lambda$<strong>单调递减</strong>。由此可证<em>one-sided z test</em>增大样本容量可以减小Type II error发生的概率。</p><p>类似的，对于一个<em>two-sided z test</em>，若有$H_0: \mu = \mu_0$和$H_1:\mu\neq\mu_0$，我们可以求得<em>OC</em>函数</p>\begin{align}\beta(\mu) &= P_\mu(接受H_0)\\\\&= P_\mu(-z_{\alpha/2} < \frac{\bar{X}-\mu_0}{\sigma/\sqrt{n}} < z_{\alpha/2})\\\\&=P_\mu(-\lambda-z_{\alpha/2} < \frac{\bar{X}-\mu}{\sigma/\sqrt{n}} < -\lambda+z_{\alpha/2})\\\\&=\phi(z_{\alpha/2}-\lambda)-\phi(-z_{\alpha/2}-\lambda)\end{align}<p>由正态分布图像的对称性可知$\phi(-x)=1-\phi(x)$，所以有</p><center>$\beta(\mu)=\phi(z_{\alpha/2}-\lambda)+\phi(z_{\alpha/2}+\lambda)-1$</center>因为此时应该选择接受$H_1$，所以$\mu\neq\mu_0$。而$z_{\alpha/2}$是一个正值，由正态分布的图像及$\lambda=\frac{\mu-\mu_0}{\sigma/\sqrt{n}}$可得当$\lambda$增大时，$\phi(z_{\alpha/2}-\lambda)$的减小的数量会大于$\phi(z_{\alpha/2}+\lambda)$增加的数量。因此，我们可以知道$\beta(\mu)$相对于$|\lambda|$**单调递减**。而$|\lambda|$对$n$**单调递增**，由此可证*two-sided z test*增大样本容量可以减小Type II error发生的概率。<p>此外，对于<em>t test</em>同样可以用相似的方法证明样本容量与Type II error发生概率的关系，不过推导过程更加复杂，本篇文章不作深入探讨。</p><h2 id="Mean-and-Median-in-a-Skewed-Distribution"><a href="#Mean-and-Median-in-a-Skewed-Distribution" class="headerlink" title="Mean and Median in a Skewed Distribution"></a>Mean and Median in a Skewed Distribution</h2><p>最后这个问题比较有趣，而且并不是我自己发现的。今年学统计的H同（ju）学（lao）曾问过我统计书上所写的当一个分布<em>skewed to the left</em>时，均值小于中位数，反之则均值大于中位数的原因。我当时无法回答，但确实觉得这是一个很有意思的一点，原来一直以为理所当然，从来没有深究过背后的原理。但直觉总归是不可靠的，于是我去做了一些research。</p><p>搞笑的是，“<em>skewness</em>”在历史上正是通过均值与中位数的大小关系定义的。。。</p><p><img src="/2018/01/25/stat/%E5%9D%91%E7%88%B9.jpg" alt=""></p><p>不过现代的“<em>skewness</em>”已经改用三阶中心矩来定义了。</p><p>如果各位读者想要更多了解这一点，可以去看看这一个<a href="https://www.zhihu.com/question/33636194" target="_blank" rel="noopener">知乎回答</a>，个人认为解释得还是非常好的。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>以上就是对于AP统计中我认为的几个主要的比较有意思的问题背后的原理。</p><p>其实在学习HFI数理方面课程的时候，总是给人一种“不求甚解”的感觉，本来应该讲究数学推导，却学成了依靠背诵知识点过关的科目。下到统计，上到AC，无一例外。这对理解这一门学科所学的内容与将来的理科学习是相当不利的。尽管出于自身水平的限制，不能一一钻研自己感兴趣的所有学过而又不理解的知识点，但我始终觉得应当在学习的过程中有一种多问“为什么”的精神：起码这也能让自己学到这门科目的一点皮毛，<del>对得起这真tm贵的学费和AP考试费</del>，而不是在学完之后发现自己仅仅只是学会怎么操作一个工具而已。</p><p>希望本文能给广大挣扎在AP统计中的出国党一点帮助，也激励自己和大家对于自己真正喜欢的学科不要仅仅满足于课程考试 <del>虽然不感兴趣的学科我经常这么干（大雾）</del>，永远保持一种“好求甚解”的习惯。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1]盛骤, 谢式千, 潘承毅. 概率论与数理统计, 第四版[M]. 高等教育出版社, 2008.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年在学习AP &lt;del&gt;TI-84/NSPIRE艺术&lt;/del&gt;统计时，总有一些骚操作让人一头雾水。而每当询问Mr. Z时，他也只是会说“This is an AP level course. You only need to know how to press the calculator.” 本篇文章讨论了几个AP统计中涵盖的公式及比较有意思的知识点背后的原理。&lt;/p&gt;
    
    </summary>
    
      <category term="Math" scheme="http://lixiuyu.cc/categories/Math/"/>
    
    
      <category term="Statistics" scheme="http://lixiuyu.cc/tags/Statistics/"/>
    
      <category term="AP" scheme="http://lixiuyu.cc/tags/AP/"/>
    
  </entry>
  
  <entry>
    <title>序-前路未知</title>
    <link href="http://lixiuyu.cc/2018/01/15/%E5%BA%8F-%E5%89%8D%E8%B7%AF%E6%9C%AA%E7%9F%A5/"/>
    <id>http://lixiuyu.cc/2018/01/15/序-前路未知/</id>
    <published>2018-01-15T06:07:01.000Z</published>
    <updated>2018-12-22T13:55:07.591Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>尽吾志也而不能至者，可以无悔矣 <br><br> 王安石 《游褒禅山记》</p></blockquote><p>今天是一月十二日，距离2017年已经过去了十二天。趁着记忆还算清晰，我想自己确实有必要为这特别的一年写点什么。</p> <img src="/2018/01/15/序-前路未知/Pit.jpeg" width="660" height="240" alt="Pittsburgh" align="center"><center><font color="#A9A9A9" size="2">8/12/2017 16:42 EST in Pittsburgh</font></center><a id="more"></a>过去一年里，我对于这个世界的认知，对于自己所想要追求的事物的思考相较以往无论在深度与广度上都不可同日而语。这或许与我从高考到留学的这一转变有关，但我想影响更大的是眼界的开阔与经历的丰富（当然进入留学圈对这两点起到了非常大的促进作用）。未来的一切仍然扑朔迷离，无论怎样试图去梳理，都感觉自己浅薄的想法触及到的都只是水中的倒影，难以捉摸。但比起在过去人生中的混沌一片，却又是好了许多。<p>现在回看我这一年似乎的确是过得十分充实，凭借着一股“自己选择的路，跪着也要走完”的决心与努力，最后虽然没有去成最初想去的地方，但也已经是非常好的结果了。不过认真想来自己其实本质上并没有什么长进，达成的大部分成就都有很强的功利性的目的，学不到什么真本事。更重要的是很多之前令我无比迷茫的问题仍然困扰着我，如何思考都寻找不到答案。新的困惑也接二连三的产生，更增添了我对自己未来该何去何从的不确定性。最时常伴随我的困扰主要有两个：</p><p>首要的便是时常让我倍感绝望，在理想主义与现实主义中摇摆不定的究竟该如何看待天赋的问题。这个难题贯穿着我的整个高中生涯，对我现在的方方面面都有着极为深厚的影响。在经历高一前中期的绝望与自暴自弃，后期重新意识到个人奋斗做到一定程度也可以带来巨大作用（当时看到知乎上<a href="https://www.zhihu.com/question/19555355#answer-142781" target="_blank" rel="noopener">Xiaodi Hou的回答</a>literally被震撼了，开始为了必须要做成的事适当牺牲睡眠）和心态的改变（认清天赋和出身已决定自己必然失败的事实但也要尽力冲击那一点渺茫的可能性，算是一种尽人事听天命释然吧），以及最后的来到HFI的客观推动（不再对是否出国犹豫不决从而导致无法决定努力方向），我在2017这一年实际上在尽力地避免继续深思这个问题，替换之的是先用向着短期目标的拼命努力麻木自己，试着解决紧迫的大学问题再做打算。这个方法确实大大减少了我自怨自艾与迷茫而浪费的时间，能去到Cornell似乎也代表着问题的解决：只要一直踏实地努力下去就好。</p><p>事实恰恰相反。越是顺利，我反而越发地心慌，因为自己其实心里清楚地认识到当前录取的成功只不过是一种假象。毕竟，我在学业上所取得一点小成绩并非真正的智力上的挑战，实际上任何人都可以通过一些技巧与勤奋所达到，只不过是很多人碍于风险不愿去尝试或是不想把自己搞得太累罢了。而一些稍微有点挑战性的东西我却半点都没有做到：想做的项目永远停留在构思阶段（比如某个图像识别的小东西），想完善自己的技术栈、提高编程能力却一直以弄标化GPA活动没时间的借口而原地踏步，就连想认真学点数学也是下载完pdf就从未翻开过。知乎用户<a href="https://www.zhihu.com/people/jianghanchen/activities" target="_blank" rel="noopener">@江踏歌</a>在他的专栏里写的这段话，用来描述我当前的状况真是再合适不过：</p><blockquote><p>我时常感觉到自己智力上和勇气上的缺陷。并且这两种缺陷互相将对方推入更深的泥潭中，永远走不出来，只能勉强维持自己不往下掉而已。</p><p>我虽然也非常想做原创性的工作，比如开发自己的分析工具（一系列复杂的更好的理解自然语言的topic model、并行化的算法以及炫酷的可视化工具），但这需要巨大的勇气和智力投入，使得我往往还没开头就把任务结束了。事实上，我已经开了超过100次头了。</p><p>但我又时常产生一些幻觉，认为我目前的工作仍然比那些比我层次低的人的工作水平高，而我几乎是将自己全部精力投入到维持这一虚幻的高明的工作上，并且在大部分的时间处于一种沾沾自喜的状态。</p><p>这是一场灾难。明明知道自己的工作其实非常没意思，但是没有勇气，更多的是没有智力上的自信投入到真正创新的工作中去。反而担心自己如果不维持现阶段水准的工作，就会失去更多，永远在患得患失。</p><p>我想这就是智力缺陷者，特别是那些和顶级智商的人差了一个档次的人的局限性。我们永远出不来，只能尽力维持自己工作体现出的智力水准不跌落而已。</p></blockquote><p>我当然不敢妄言自己可以和江踏歌相提并论，但尽管层次不同，心境却是相似的：这一年我虽然做了不少事，熬了许多夜，并时常为取得的成就沾沾自喜，可我做的这些东西，有多少是自己真真正正想做的有意义的事呢？论文在数学大神眼里不值一提，AP知识浅尝辄止，各类竞赛也远比不上国内比赛的难度。申上Cornell又如何？我现在的水平应该比不上任何学科竞赛的省一，更别提能进队、上清北的同学了。我与那些自己所佩服的、真正有实力的人之间的距离一丁儿点都没有减小，却愈发觉得自己更接近于所谓的“智力缺陷者”了。因此，尽管过了一年，我还是会时常诘问自己：“以你的天赋，真的可以支撑做学术的理想吗？”这个困扰，看来得等到上大学后才可能找到答案了。</p><p>第二点则是对自己所追求事物的困惑。在HFI与留学党这一圈子里见识了各种各样的人与他们所想要的各种各样的活法，感触还是挺深的。第一次发现可供自己的选择路子居然这么多，也让我开始有些迷茫到底是坚持自己的初心还是去更多地尝试其他事物。不过这个话题老生常谈，写出来想必也是索然无味，还是自己去悟吧，暂且略过不提。</p><p>总之，2017年依然是不停地怀疑自己的智商，越发感到很多人的天资、努力和取得的成就是自己可望而不可即的，时不时在浅色床单上痛哭的迷惘一年。不过确实也努力了，并幸运地取得了还算不错的成果。这一年的成长与阅历和眼界的丰富，也绝对是之前从未有能相提并论的。现在所能做的，就是不管自己天赋如何，都先别胡思乱想，而是抓住当下，正如香港的一位戴黑框眼镜的长者所言：<img src="/2018/01/15/序-前路未知/%E5%BA%8F-%E5%89%8D%E8%B7%AF%E6%9C%AA%E7%9F%A5/%E6%9D%8E%E5%98%89%E8%AF%9A.png" alt=""></p><p>继续奋斗下去吧，毕竟我还年轻，热血还没有凉，仍然有足够的青春为自己的理想主义可能犯下的错挥霍。即使最后证明了自己不是学术的这块料，也能够有王文公所言的“尽吾志也而不能至者，可以无悔矣”的感觉吧。</p><hr><h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><p>这篇文章从十二日断断续续写到十五日（效率低下╮(￣▽￣)╭），算是我对2017年感想的一个整理，也可以作为我整个高中生涯的总结（毕竟已经是大学生了）。写作的动机呢其实挺复杂的，一直以来都有很多想法想要抒发，加上周围许多同学都开了自己的公众号，便也有意用自己拙劣的文笔来分享自己的所思所想以寻找和引发各位读者的共鸣。但又出于以往一直不善于表达自己的原因，纠结了好一段时间到底写不写这篇文。最终还是决定下笔写出来，毕竟做做总结可以更清晰地审视自己，激励与提醒自己继续不忘初心，奋斗下去。而写文章并发出去，正好也作为进入人生新的阶段一个改变，尝试一下新事物吧。</p><p>此外，由于自己未满十八岁写不了公众号TUT，爸妈也不方便提供身份证，便决定提早开放自己的博客，发在上面，作为一个开头语（本来想晚点先能够放些技术干货不显得这么寒酸再公开的，现在啥都没有_(:з」∠)_）。以后应该什么东西都会写点（学术，随笔，读书笔记 etc.），希望可以坚持下去。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;尽吾志也而不能至者，可以无悔矣 &lt;br&gt;&lt;br&gt; 王安石 《游褒禅山记》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;今天是一月十二日，距离2017年已经过去了十二天。趁着记忆还算清晰，我想自己确实有必要为这特别的一年写点什么。&lt;/p&gt;
 &lt;img src=&quot;/2018/01/15/序-前路未知/Pit.jpeg&quot; width=&quot;660&quot; height=&quot;240&quot; alt=&quot;Pittsburgh&quot; align=&quot;center&quot;&gt;
&lt;center&gt;&lt;font color=&quot;#A9A9A9&quot; size=&quot;2&quot;&gt;8/12/2017 16:42 EST in Pittsburgh&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://lixiuyu.cc/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="总结" scheme="http://lixiuyu.cc/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
